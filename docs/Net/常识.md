1. 字符串中 string str=null 和 string str=""和 string str=string.Empty 的区别？

string.Empty 相当于“”,Empty 是⼀个静态只读的字段。 string str="" ,初始化对象，并分配⼀个空字符串

的内存空间 string str=null,初始化对象，不会分配内存空间

2. byte b = 'a'; byte c = 1; byte d = 'ab'; byte e = '啊'; byte g = 256; 这些变量有些

错误是错再哪⾥?

本题考查的是数据类型能承载数据的⼤⼩。

1byte =8bit，1 个汉字=2 个 byte，1 个英⽂=1 个 byte=8bit

所以 bc 是对的，deg 是错的。'a'是 char 类型，a 错误

java byte 取值范围是-128~127, ⽽ C#⾥⼀个 byte 是 0~255

3.string 和 StringBuilder 的区别,两者性能的⽐较

都是引⽤类型，分配再堆上

StringBuilder 默认容量是 16，可以允许扩充它所封装的字符串中字符的数量.每个 StringBuffer 对象都有⼀

定的缓冲区容量，当字符串⼤⼩没有超过容量时，不会分配新的容量，当字符串⼤⼩超过容量时，会⾃动

增加容量。

对于简单的字符串连接操作，在性能上 stringbuilder 不⼀定总是优于 strin 因为 stringbulider 对象的创建也

消耗⼤量的性能，在字符串连接⽐较少的情况下，过度滥⽤ stringbuilder 会导致性能的浪费⽽⾮节约，只

有⼤量⽆法预知次数的字符串操作才考虑 stringbuilder 的使⽤。从最后分析可以看出如果是相对较少的字

符串拼接根本看不出太⼤差别。

Stringbulider 的使⽤，最好制定合适的容量值，否则优于默认值容量不⾜⽽频繁的进⾏内存分配操作，是

不妥的实现⽅法。

参考链接：https://www.cnblogs.com/haofuqi/p/4826262.html

4.什么是扩展⽅法？

⼀句话解释，扩展⽅法使你能够向现有类型“添加”⽅法，⽆需修改类型

2 条件：按扩展⽅法必须满⾜的条件，1.必须要静态类中的静态⽅法 2.第⼀个参数的类型是要扩展的类型，并

且需要添加 this 关键字以标识其为扩展⽅法

建议：通常，只在不得已的情况下才实现扩展⽅法，并谨慎的实现

使⽤：不能通过类名调⽤，直接使⽤类型来调⽤

5.byte a =255;a+=5;a 的值是多少？

byte 的取值范围是-2 的 8 次⽅⾄ 2 的 8 次⽅-1，-256 ⾄ 258，a+=1 时，a 的值时 0，a+=5 时，a 的值是 0，所

以 a+=5 时，值是 4

6.什么是装箱和拆箱？

装箱就是隐式地将⼀个值类型转换成引⽤类型，如：

1 int i=0;

2 Syste.Object obj=i;

拆箱就是将引⽤类型转换成值类型，如：

1 int i=0;

2 System.Object obj=i;

3 int j=(int)obj;（将 obj 拆箱）

7.值类型和引⽤类型的区别

值类型变量是直接包含值。将⼀个值类型变量赋给另⼀个值类型变量，是复制包含的值，默认值是 0。

引⽤类型变量的赋值只复制对对象的引⽤，⽽不复制对象本身，默认值是 null

值类型有整形、浮点型、bool、枚举。

引⽤类型有 class、delegate、Object、string

34

值类型存储在栈中，引⽤类型存储在堆中

运算符：创建对象实例

修饰符：在派⽣类定义⼀个重名的⽅法，隐藏掉基类⽅法

约束：泛型约束定义，约束可使⽤的泛型类型,如：

int？为可空类型，默认值可以是 null

int 默认值是 0

int?是通过 int 装箱为引⽤类型实现

⼀句话解释就是：将⽅法当作参数传⼊另⼀个⽅法的参数。 .net 中有很多常⻅的委托如：Func 、Action

作⽤：提⾼⽅法的扩展性

位运算是最快，使⽤的是位运算 逻辑左位移<<。 ⽅法是 2<<3 相当于 0000 0000 0000 0010 （

2 的 16 位

int ⼆进制）左移三位就是 0000 0000 0001 0000（

16 的⼆进制）

都可以标识⼀个常量。主要有以下区别：

8.new 关键字的作⽤?

1 public class ItemFactory<T> where T : IComparable, new()

2 {

3 }

9. int?和 int 有什么区别?
10. C#中的委托是什么？

11.⽤最有效的⽅法算出 2 乘以 8 等于⼏？

12.const 和 readonly 有什么区别？5

1、初始化位置不同。const 必须在声明的同时赋值；readonly 即可以在声明处赋值，也可以在静态构造⽅

法（必须是静态构造⽅法，普通构造⽅法不⾏）⾥赋值。

2、修饰对象不同。const 即可以修饰类的字段，也可以修饰局部变量；readonly 只能修饰类的字段

3、const 是编译时常量，在编译时确定该值；readonly 是运⾏时常量，在运⾏时确定该值。

4、const 默认是静态的；⽽ readonly 如果设置成静态需要显示声明

5、修饰引⽤类型时不同，const 只能修饰 string 或值为 null 的其他引⽤类型；readonly 可以是任何类型。

4（

100）、5（

101）、8（

1000）、16（

10000）

取模运算： ⽤ number%2==0 可以判断，但是这个有点低级

位运算：（使⽤位运算逻辑并，两个位上的都为 1 才是 1，其余都是 0，判断是否等于 0）

4&3 相当于 100&011 ，结果是 000 等于 0，所以 4 是 2 的 n 次⽅

5&4 相当于 101&100，结果是 100 不等于 0，所以 5 不是 2 的 n 次⽅

如果要问如果是 2 的 N 次⽅，这个 N 是多少？这该怎么算？

13.现有⼀个整数 number，请写⼀个⽅法判断这个整数是否是 2 的 N 次⽅

1 private static byte get(int n)

2 {

3 byte number = 1;

4 while (n/2!=1)

5 {

6 n = n / 2;

7 number += 1;

8 }

9 return number;

10 }14.CTS、CLS、CLR 分别作何解释

CTS：通⽤语⾔系统。CLS：通⽤语⾔规范。CLR：公共语⾔运⾏库。

CTS：Common Type System 通⽤类型系统。Int32、Int16→int、String→string、Boolean→bool。

每种语⾔都定义了⾃⼰的类型，.Net 通过 CTS 提供了公共的类型，然后翻译⽣成对应的.Net 类型。

CLS：Common Language Specification 通⽤语⾔规范。不同语⾔语法的不同。每种语⾔都有⾃⼰的语

法，.Net 通过 CLS 提供了公共的语法，然后不同语⾔翻译⽣成对应的.Net 语法。

CLR：Common Language Runtime 公共语⾔运⾏时，就是 GC、JIT 等这些。有不同的 CLR，⽐如服务

器 CLR、Linux CLR（Mono）、Silverlight CLR(CoreCLR)。相当于⼀个发动机，负责执⾏ IL。

15.在.net 中，配件的意思是？

程序集。（中间语⾔，源数据，资源，装配清单）

16.分析下⾯代码，a、b 的值是多少？

1 string strTmp = "a1 某某某";

2 int a = System.Text.Encoding.Default.GetBytes(strTmp).Length;

3 int b = strTmp.Length;

分析：⼀个字⺟、数字占⼀个 byte，⼀个中⽂占占两个 byte，所以 a=8,b=5

17.Strings = new String(“xyz”);创建了⼏个 String Object?

两个对象，⼀个是“xyz”,⼀个是指向“xyz”的引⽤对象 s。

18.静态成员和⾮静态成员的区别

1.静态成员⽤ statis 修饰符声明，在类被实例化时创建，通过类进⾏访问

2.不带 statis 的变量时⾮静态变量，在对象被实例化时创建，通过对象进⾏访问，

63.静态⽅法⾥不能使⽤⾮静态成员，⾮静态⽅法可以使⽤静态成员

4.静态成员属于类，⽽不属于对象

19.c#可否对内存直接操作

C#在 unsafe 模式下可以使⽤指针对内存进⾏操作, 但在托管模式下不可以使⽤指针，C#NET 默认不运⾏

带指针的，需要设置下，选择项⽬右键->属性->选择⽣成->“允许不安全代码”打勾->保存

20.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?

s1+1 不能显式转换成 short 类型，可以修改为 s1 =(short)(s1 + 1) 。short s1 = 1; s1 += 1 正确

21.什么是强类型，什么是弱类型？哪种更好些？为什么?

强类型是在编译的时候就确定类型的数据，在执⾏时类型不能更改，⽽弱类型在执⾏的时候才会确定类

型。没有好不好，⼆者各有好处，强类型安全，因为它事先已经确定好了，⽽且效率⾼。

⼀般⽤于编译型编程语⾔，如 c++,java,c#,pascal 等,弱类型相⽐⽽⾔不安全，在运⾏的时候容易出现错

误，但它灵活，多⽤于解释型编程语⾔，如 javascript,vb,php 等

22.using 关键字的作⽤

1.引⽤命名空间，也可 using 别名

2.释放资源，实现了 IDisposiable 的类在 using 中创建，using 结束后会⾃定调⽤该对象的 Dispose ⽅法，

释放资源。

23.ref 和 out 有什么区别

1.都是按引⽤类型进⾏传递

2.属性不是变量不能作为 out、ref 参数传递

3.ref 参数必须初始化。out 不需要初始化

4.作⽤，当⽅法有多个返回值时，out ⾮常有⽤

724.a.Equals(b)和 a==b ⼀样吗？

不⼀样，a==b 仅仅表示 a 和 b 值相等，a.Equals(b)表示 a 与 b ⼀致

25.下⾯这段代码求值

1 class Class1

2 {

3 internal static int count = 0;

4 static Class1()

5 {

6 count++;

7 }

8 public Class1()

9 {

10 count++;

11 }

12 }

13 Class1 o1 = new Class1();

14 Class1 o2 = new Class1();

o1.count 的值是多少？

答案：3，静态 构造⽅法计算⼀次，两个实例化对象计算两次。

26.关于构造函数说法正确的是哪个？

a)构造函数可以声明返回类型。

b)构造函数不可以⽤ private 修饰

c)构造函数必须与类名相同

d)构造函数不能带参数

89

答案：c ，构造函数必须与类名相同，可以传递多个传递，作⽤就是便于初始化对象成员，不能有任何返

回类型

Math.Round(11.5)=12

Math.Round(-11.5)=-12

相同点

&和&&都可作逻辑与的运算符，表示逻辑与（

and），当运算符两边的表达式的结果都为 true 时，其结果

才为 true，否则，只要有⼀⽅为 false，则结果为 false。（

ps：当要⽤到逻辑与的时候&是毫⽆意义，&本

身就不是⼲这个的）

不同点

···

if(loginUser!=null&&string.IsnullOrEmpty(loginUser.UserName))

···

&&具有短路的功能，即如果第⼀个表达式为 false，则不再计算第⼆个表达式，对于上⾯的表达式，当

loginUser 为 null 时，后⾯的表达式不会执⾏，所以不会出现 NullPointerException 如果将&&改为&，则会

抛出 NullPointerException 异常。（

ps：所以说当要⽤到逻辑与的时候&是毫⽆意义的）

& 是⽤作位运算的。

总结

&是位运算，返回结果是 int 类型 &&是逻辑运算，返回结果是 bool 类型

1.i++是先赋值，然后再⾃增；++i 是先⾃增，后赋值。

2.i=0，i++=0，++i=1； Console.WriteLine(i==i); 结果位 true

27.Math.Round(11.5)等於多少? Math.Round(-11.5)等於多少?

28.&和&&的区别

29. i 和 i 有什么区别？30.as 和 is 的区别

as 在转换的同时判断兼容性，如果⽆法进⾏转换，返回位 null（没有产⽣新的对象），as 转换是否成功判

断的依据是是否位 null is 只是做类型兼容性判断，并不执⾏真正的类型转换，返回 true 或 false，对象为

null 也会返回 false。

as ⽐ is 效率更⾼，as 只需要做⼀次类型兼容检查

10.NET/C#⾯试题汇总系列：⾯向对象

1.什么是构造函数？

概念：构造函数的⽅法名与类型相同、没有返回类型

作⽤：完成对类的对象初始化

创建⼀个类的新对象时，系统会⾃动调⽤该构造函数初始化新对象， 如果没有写定义，那么系统会⾃动提

供⼀个不带任何参数的 public 构造函数

2.class 和 struct 的区别?

相同点 都可以实现接⼝

不同点

1.class 是引⽤类型，struct 是值类型

2.class 允许继承、被继承，struct 不允许，只能继承接⼝

3.class 可以初始化变量，struct 不可以

4.class 可以有⽆参的构造函数，struct 不可以，必须是有参的构造函数，⽽且在有参的构造函数必须初始

化所有成员

使⽤场景

1.Class ⽐较适合⼤的和复杂的数据，表现抽象和多级别的对象层次时。

2.Struct 适⽤于作为经常使⽤的⼀些数据组合成的新类型，表示诸如点、矩形等主要⽤来存储数据的轻量

级对象时，偏简单值。

3.Struct 有性能优势，Class 有⾯向对象的扩展优势。

3.简述⼀下⾯向对象的三⼤特性？

1112

封装、继承、多态。

封装：是通过把对象的属性的实现细节隐藏起来，仅对外提供公共的访问⽅法。

继承：是通过⼦类继承基类、继承抽象类、继承接⼝实现的。

多态：是通过重写基类的 override ⽅法、重写虚⽅法实现的。 好处是：⽅便维护、易扩展。 缺点是：⽐

⾯向过程性能低。

构造器 Constructor 不能被继承，因此不能重写，但可以被重载

相同点：都不能直接实例化 不同点：

1.抽象类⽤ abstract 修饰、接⼝⽤ interface 修饰

2.抽象类中的⽅法可以实现，也可以不实现，有抽象⽅法的类⼀定要⽤ abstract 修饰，接⼝中的⽅法不允

许实现

3.抽象类只能单继承，接⼝⽀持多实现

4.抽象类有构造⽅法，接⼝不能有构造⽅法

5.接⼝只负责功能的定义，通过接⼝来规范类的，（有哪些功能），⽽抽象类即负责功能的定义有可以实

现功能（实现了哪些功能）

执⾏顺序：⽗类，⼦类，静态块，静态字段，⾮静态块，⾮静态字段，构造器，⽅法

4.构造函数是否能被重写？

5.抽象类和接⼝有什么区别？

6..类的执⾏顺序？

7.接⼝是否可继承接⼝？抽象类是否可实现（

implements）接⼝？抽象类是否可继承实现类

（

concrete class）？接⼝可以继承接⼝，抽象类可以实现接⼝，抽象类可以继承实现类，但前提是实现类必须有明确的构造函

数。

8.继承最⼤的好处？

对⽗类成员进⾏重⽤，增加代码的可读性、灵活性。

9.请说说引⽤和对象?

对象和引⽤时分不开的，对象⽣成⼀个地址，放在堆⾥⾯，引⽤则指向这个地址，放在栈⾥⾯

10.什么是匿名类，有什么好处？

不⽤定义、没有名字的类，使⽤⼀次便可丢弃。好处是简单、随意、临时的。

11.重写和重载的区别?

重写⽅法：关键字⽤ override 修饰，派⽣类重写基类的⽅法，⽅法命名、返回类型，参数必须相同

重载⽅法：⽅法名必须相同，参数列表必须不相同，返回类型可以不相同。

作⽤：重写主要是实现⾯向对象的多态性、重载主要是实现实例化不同的对象

12.C#中有没有静态构造函数，如果有是做什么⽤的？

特点： 静态构造函数既没有访问修饰符，也没有参数。在创建第⼀个实例或引⽤任何静态成员之前，将⾃

动调⽤静态构造函数来初始化类。⽆法直接调⽤静态构造函数。在程序中，⽤户⽆法控制何时执⾏静态构

造函数。 ⽤途 : 当类使⽤⽇志⽂件时，将使⽤这种构造函数向⽇志⽂件中写⼊项。

13.怎样理解静态变量？静态成员和⾮静态成员的区别？

静态变量属于类，⽽不属于对象；并对所有对象所享；静态成员在加类的时候就被加载。

14.属性能在接⼝中声明吗？

13 可以，不能有访问修饰符，不能初始化赋值。

15.在项⽬中为什么使⽤接⼝？接⼝的好处是什么？什么是⾯向接⼝开发？

接⼝是⼀种约束，描述类的公共⽅法/公共属性，不能有任何的实现

好处是：结构清晰，类之间通信简单易懂，扩展性好，提⾼复⽤性。

⾯向 interface 编程，原意是指⾯向抽象协议编程，实现者在实现时要严格按协议来办。

16.什么时候⽤重载？什么时候⽤重写？

当⼀个类需要⽤不同的实现来做同⼀件事情，此时应该⽤重写，⽽重载是⽤不同的输⼊做同⼀件事情

17.静态⽅法可以访问⾮静态变量吗？如果不可以为什么？

静态⽅法和⾮静态变量不是同⼀⽣命周期，静态⽅法属于类，⾮静态变量属于具体的对象，静态⽅法和具

体的对象没有任何关联

18.在.Net 中所有可序列化的类都被标记为\_?

[serializable]

19.C#中 property 与 attribute 的区别，他们各有什么⽤处，这种机制的好处在哪⾥？

⼀个是属性，⽤于存取类的字段，⼀个是特性，⽤来标识类，⽅法等的附加性质

20.当使⽤ new B()创建 B 的实例时，产⽣什么输出？

1 using System;

2 class A

3 {

4 public A()

5 {

6 PrintFields();

147 }

8 public virtual void PrintFields(){}

9 }

10 class B:A

11 {

12 int x=1;

13 int y;

14 public B()

15 {

16 y=-1;

17 }

18 public override void PrintFields()

19 {

20 Console.WriteLine("x={0},y={1}",x,y);

21 }

22 }

答：X=1,Y=0;

21.能⽤ foreach 遍历访问的对象需要实现 接⼝或声明⽅法的类型

答：IEnumerable 、 GetEnumerator。

15.NET/C#⾯试题汇总系列：集合、异常、泛型、

LINQ、委托、EF！

1. IList 接⼝与 List 的区别是什么?

IList 泛型接⼝是 Icollection 接⼝的⼦代，并且是所有⾮泛型列表的基接⼝。 Ilist 实现有三种类别：只

读、固定⼤⼩、可变⼤⼩。 ⽆法修改只读 Ilist。 固定⼤⼩的 Ilist 不允许添加或移除元素，但允许修改现

有元素。 可变⼤⼩的 Ilist 允许添加、移除和修改元素。

IList 是个接⼝,定义了⼀些操作⽅法这些⽅法要你⾃⼰去实现，当你只想使⽤接⼝的⽅法时,这种⽅式⽐较

好.他不获取实现这个接⼝的类的其他⽅法和字段，有效的节省空间．

List 是个类型 已经实现了 IList 定义的那些⽅法。

1 List List11 =new List ();

是想创建⼀个 List，⽽且需要使⽤到 List 的功能，进⾏相关操作。

⽽

1 IList IList11 =new List ();

只是想创建⼀个基于接⼝ IList 的对象的实例，只是这个接⼝是由 List 实现的。所以它只是希望使⽤到 IList

接⼝规定的功能⽽已。

2.泛型的主要约束和次要约束是什么？

当⼀个泛型参数没有任何约束时，它可以进⾏的操作和运算是⾮常有限的，因为不能对实参进⾏任何类型

上的保证，这时候就需要⽤到泛型约束。泛型的约束分为：主要约束和次要约束，它们都使实参必须满⾜

⼀定的规范，C#编译器在编译的过程中可以根据约束来检查所有泛型类型的实参并确保其满⾜约束条件。

（

1）主要约束

1617

⼀个泛型参数⾄多拥有⼀个主要约束，主要约束可以是⼀个引⽤类型、class 或者 struct。如果指定⼀个引

⽤类型（

class），那么实参必须是该类型或者该类型的派⽣类型。相反，struct 则规定了实参必须是⼀个

值类型。下⾯的代码展示了泛型参数主要约束：

1 public class ClassT1<T> where T : Exception

2 {

3 private T myException;

4 public ClassT1(T t)

5 {

6 myException = t;

7 }

8 public override string ToString()

9 {

10 // 主要约束保证了 myException 拥有 source 成员

11 return myException.Source;

12 }

13 }

14

15 public class ClassT2<T> where T : class

16 {

17 private T myT;

18 public void Clear()

19 {

20 // T 是引⽤类型，可以置 null

21 myT = null;

22 }

23 }

24

25 public class ClassT3<T> where T : struct

26 {

27 private T myT;

28 public override string ToString()

29 {

30 // T 是值类型，不会发⽣ NullReferenceException 异常

31 return myT.ToString();

32 }(2)次要约束

次要约束主要是指实参实现的接⼝的限定。对于⼀个泛型，可以有 0 到⽆限的次要约束，次要约束规定了实

参必须实现所有的次要约束中规定的接⼝。次要约束与主要约束的语法基本⼀致，区别仅在于提供的不是

⼀个引⽤类型⽽是⼀个或多个接⼝。例如我们为上⾯代码中的 ClassT3 增加⼀个次要约束：

1 public class ClassT3<T> where T : struct, IComparable

2 {

3 ......

4 }

3. 如何把⼀个 array 复制到 arrayist ⾥?

1 foreach( object arr in array)

2 {

3 arrayist.Add(arr);

4 }

4.List, Set, Map 是否继承⾃ Collection 接⼝?

List，Set 是，Map 不是

5. Set ⾥的元素是不能重复的，那么⽤什么⽅法来区分重复与否呢? 是⽤==还是 equals()? 它

们有何区别?

Set ⾥的元素是不能重复的，那么⽤ iterator()⽅法来区分重复与否。equals()是判读两个 Set 是否相等。

equals()和==⽅法决定引⽤值是否指向同⼀对像，equals()在类中被覆盖，为的是当两个分离的对象的内

容和类型相配的话，返回真值。

6.有 50 万个 int 类型的数字，现在需要判断⼀下⾥⾯是否存在重复的数字，请你简要说⼀下思

路。

1.使⽤ C#的 List 集合⾃带的去重⽅法，例如 Distinct()，GroupBy()等

182.利⽤ Dictionary 的 Key 值唯⼀的特性，HashSet 元素值唯⼀的特性 进⾏判断

7.数组有没有 length()这个⽅法? String 有没有 length()这个⽅法？

数组没有 length()这个⽅法，有 length 的属性。String 有有 length()这个⽅

法。

8.⼀个整数 List 中取出最⼤数（找最⼤值）。不能⽤ Max ⽅法。

1 private static int GetMax(List<int> list)

2 {

3 int max = list[0];

4 for (int i = 0; i < list.Count; i++)

5 {

6 if (list[i]>max)

7 {

8 max = list[i];

9 }

10 }

11 return max;

12 }

9. C#异常类有哪些信息？

C#中，所有异常都继承⾃ System.Exception 类，Exception 类定义了 C#异常应该具有的信息和⽅法。值

得注意的属性有：

1 public virtual string Message { get; }// 错误的信息，⽂字描述

2 public virtual string StackTrace { get; }// 发⽣异常的调⽤堆栈信息

3 public System.Reflection.MethodBase TargetSite { get; }//引发这个错

误的⽅法

4 public Exception InnerException { get; }// ⼦异常

10. 如何创建⼀个⾃定义异常?

19 根据类继承原则和异常处理原则，我们可以使⽤以下⽅式来⾃定义⼀个类：

1 public class CustomException : Exception

2 {

3 }

11. 利⽤ IEnumerable 实现斐波那契数列⽣成?

1 IEnumerable<int> GenerateFibonacci(int n)

2 {

3 if (n >= 1) yield return 1;

4

5 int a = 1, b = 0;

6 for (int i = 2; i <= n; ++i)

7 {

8 int t = b;

9 b = a;

10 a += t;

11

12 yield return a;

13 }

14 }

12.请利⽤ foreach 和 ref 为⼀个数组中的每个元素加 1

注意 foreach 不能⽤ var ，也不能直接⽤ int ，需要 ref int ，注意 arr 要转换为 Span 。

1 int[] arr = { 1, 2, 3, 4, 5};

2 Console.WriteLine(string.Join(",", arr)); // 1,2,3,4,5

3

4 foreach (ref int v in arr.AsSpan())

5 {

6 v++;

7 }

208

9 Console.WriteLine(string.Join(",", arr)); // 2,3,4,5,6

13.如何针对不同的异常进⾏捕捉？

1 public class Program

2 {

3 public static void Main(string[] args)

4 {

5 Program p = new Program();

6 p.RiskWork();

7

8 Console.ReadKey();

9 }

10

11 public void RiskWork()

12 {

13 try

14 {

15 // ⼀些可能会出现异常的代码

16 }

17 catch (NullReferenceException ex)

18 {

19 HandleExpectedException(ex);

20 }

21 catch (ArgumentException ex)

22 {

23 HandleExpectedException(ex);

24 }

25 catch (FileNotFoundException ex)

26 {

27 HandlerError(ex);

28 }

29 catch (Exception ex)

30 {

31 HandleCrash(ex);

32 }

33 }

2134

35 // 这⾥处理预计可能会发⽣的，不属于错误范畴的异常

36 private void HandleExpectedException(Exception ex)

37 {

38 // 这⾥可以借助 log4net 写⼊⽇志

39 Console.WriteLine(ex.Message);

40 }

41

42 // 这⾥处理在系统出错时可能会发⽣的，⽐较严重的异常

43 private void HandlerError(Exception ex)

44 {

45 // 这⾥可以借助 log4net 写⼊⽇志

46 Console.WriteLine(ex.Message);

47 // 严重的异常需要抛到上层处理

48 throw ex;

49 }

50

51 // 这⾥处理可能会导致系统崩溃时的异常

52 private void HandleCrash(Exception ex)

53 {

54 // 这⾥可以借助 log4net 写⼊⽇志

55 Console.WriteLine(ex.Message);

56 // 关闭当前程序

57 System.Threading.Thread.CurrentThread.Abort();

58 }

59 }

14.如何避免类型转换时的异常？

其中有些是确定可以转换的（⽐如将⼀个⼦类类型转为⽗类类型），⽽有些则是尝试性的（⽐如将基类引

⽤的对象转换成⼦类）。当执⾏常识性转换时，我们就应该做好捕捉异常的准备。

当⼀个不正确的类型转换发⽣时，会产⽣ InvalidCastException 异常，有时我们会⽤ try-catch 块做⼀些尝

试性的类型转换，这样的代码没有任何错误，但是性能却相当糟糕，为什么呢？异常是⼀种耗费资源的机

制，每当异常被抛出时，异常堆栈将会被建⽴，异常信息将被加载，⽽通常这些⼯作的成本相对较⾼，并

且在尝试性类型转换时，这些信息都没有意义。

在.NET 中提供了另外⼀种语法来进⾏尝试性的类型转换，那就是关键字 is 和 as 所做的⼯作。

22（

1）is 只负责检查类型的兼容性，并返回结果：true 和 false。→ 进⾏类型判断

1 public static void Main(string[] args)

2 {

3 object o = new object();

4 // 执⾏类型兼容性检查

5 if(o is ISample)

6 {

7 // 执⾏类型转换

8 ISample sample = (ISample)o;

9 sample.SampleShow();

10 }

11

12 Console.ReadKey();

13 }

（

2）as 不仅负责检查兼容性还会进⾏类型转换，并返回结果，如果不兼容则返回 null 。→ ⽤于类型转

型

1 public static void Main(string[] args)

2 {

3 object o = new object();

4 // 执⾏类型兼容性检查

5 ISample sample = o as ISample;

6 if(sample != null)

7 {

8 sample.SampleShow();

9 }

10 Console.ReadKey();

11 }

两者的共同之处都在于：不会抛出异常！综上⽐较，as 较 is 在执⾏效率上会好⼀些，在实际开发中应该

量才⽽⽤，在只进⾏类型判断的应⽤场景时，应该多使⽤ is ⽽不是 as。

15.Serializable 特性有什么作⽤？

23 通过上⾯的流类型可以⽅便地操作各种字节流，但是如何把现有的实例对象转换为⽅便传输的字节流，就

需要使⽤序列化技术。对象实例的序列化，是指将实例对象转换为可⽅便存储、传输和交互的流。在.NET

中，通过 Serializable 特性提供了序列化对象实例的机制，当⼀个类型被申明为 Serializable 后，它就能被

诸如 BinaryFormatter 等实现了 IFormatter 接⼝的类型进⾏序列化和反序列化。

16.委托是什么？

委托是寻址的.NET 版本。在 C++中，函数指针只不过是⼀个指向内存位置的指针，它不是类型安全的。我

们⽆法判断这个指针实际指向什么，像参数和返回类型等项久更⽆从知晓了。

⽽.NET 委托完全不同，委托是类型安全的类，它定义了返回类型和参数的类型。委托类不仅包含对⽅法的

引⽤，也可以包含对多个⽅法的引⽤。

17.如何⾃定义委托？

声明⼀个委托类型，它的实例引⽤⼀个⽅法，该⽅法获取⼀个 int 参数，返回 void。

1 public delegate void Feedback(int num);

理解委托的⼀个要点是它们的安全性⾮常⾼。在定义委托时，必须给出它所表示的⽅法的签名和返回类型

等全部细节。

理解委托的⼀种⽐较好的⽅式是把委托当作这样⼀件事情：它给⽅法的签名和返回类型指定名称。

其语法类似于⽅法的定义，需要在定义⽅法的前⾯加上 delegate 关键字。定义委托基本上就是定义⼀个新

的类，所以可以在任何地⽅定义类的相同地⽅定义委托，也就是说，可以在另⼀个类的内部定义，也可以

在任何类的外部定义，还可以在名称控件中把委托定义为定义为顶层对象。访问修饰符可以是

public/private/protected 等。

18 .NET 默认的委托类型有哪⼏种？

1. Action < T >

泛型 Action 委托表示引⽤⼀个 void 返回类型的⽅法。这个委托类存在 16 种重载⽅法。

24 例如 Action<in T1,In T2>调⽤没有参数的⽅法

2.Func< T >

Func 调⽤带返回类型的⽅法。有 16 种重载⽅法。

例如 Func 委托类型可以调⽤带返回类型且⽆参数的⽅法，Func<in T,out TResult>委托类型调⽤带有 4 个

参数和⼀个返回类型的⽅法。

19.什么是泛型委托？

Action 就是泛型委托。

注意事项：

1.建议尽量使⽤这些委托类型，⽽不是在代码中定义更多的委托类型。这样可以减少系统中的类型数⽬，同

时简化编码

2.如果需要使⽤ ref 或 out 关键字，以传引⽤的⽅式传递⼀个参数，就可能不得不定义⾃⼰的委托：

delegate void Test(ref int i)

3.如果委托要通过 C#的 params 关键字获取可变数量的额参数，要为委托的任何桉树指定默认值，或者要

对委托的泛型类型参数进⾏约束，也必须定义⾃⼰的委托类型

delegate void EventHandler(Object sender, TEventArgs e)

where TEventArgs : EventArgs;

4.使⽤获取泛型实参和返回值的委托时，可利⽤逆变与协变。逆变：⽗类转换为⼦类；协变：⼦类转换为

⽗类

20. 什么事匿名⽅法?

匿名⽅法是⽤作委托的参数的⼀段代码。

1 //匿名⽅法,例 1

2 Func<int, int> anon = delegate(int i)

3 {

254 i = i+1;

5 return i;

6 };

7 //输出 2

8 Console.WriteLine(anon(1));

9 //匿名⽅法,例 2

10 Action<int> anon2 = delegate(int i)

11 {

12 i = i + 1;

13 };

14 //输出 2

15 Console.WriteLine(anon(1));

21.什么是闭包？

通过 Lambda 表达式可以访问 Lambda 表达式块外部的变量，这成为闭包。

当引⽤外部变量时，需要注意，外部变量变化时，lambda 表达式的结果也可能会随着外部变量变化⽽变

化。

如下⾯的例⼦：

1 int y = 5;

2 Func<int, int> lambda = x => x + y;

3 Console.WriteLine(lambda(1));

4 y = 10;

5 Console.WriteLine(lambda(1));

22.EF(Entity Framework)是什么？

实体框架 EF 是http://ADO.NET中的⼀组⽀持开发⾯向数据的软件应⽤程序的技术，是微软的⼀个ORM框

架。

主要有三种⽅式：

Database FirstDatabase First”模式

26 我们称之为“数据库优先”，前提是你的应⽤已经有相应的数据库，你可以使⽤ EF 设计⼯具根据数据库⽣成

数据数据类，你可以使⽤ Visual Studio 模型设计器修改这些模型之间对应关系。

来⾃ https://blog.csdn.net/u011854789/article/details/72783902 Model FirstModel First 我们称

之为“模型优先”，这⾥的模型指的是“ADO.NET Entity Framework Data Model”，此时你的应⽤并没有

设计相关数据库，在 Visual Studio 中我们通过设计对于的数据模型来⽣成数据库和数据类。

Code FirstCode First 模式我们称之为“代码优先”模式，是从 EF4.1 开始新建加⼊的功能。

使⽤ Code First 模式进⾏ EF 开发时开发⼈员只需要编写对应的数据类（其实就是领域模型的实现过程），

然后⾃动⽣成数据库。这样设计的好处在于我们可以针对概念模型进⾏所有数据操作⽽不必关⼼数据的存

储关系，使我们可以更加⾃然的采⽤⾯向对象的⽅式进⾏⾯向数据的应⽤程序开发。

23.什么是 ORM?

ORM 指的是⾯向对象的对象模型和关系型数据库的数据结构之间的互相转换。

(表实体跟表之间的相互转换)

ORM 框架有很多，EF 框架是 ORM 框架的其中⼀种，是实现了 ORM 思想的框架。

O=>表实体

M=>映射关系

R=>数据库.表

24.为什么⽤ EF ⽽不⽤原⽣的 ADO.NET?

1.极⼤的提⾼开发效率:EF 是微软⾃⼰的产品,开发中代码都是强类型的,

xiefl 代码效率⾮常⾼,⾃动化程度⾮常⾼,命令式的编程.

2.EF 提供的模型设计器⾮常强⼤,不仅仅带来了设计数据库的⾰命,也附带来的⾃动化模型代码的

功能也极⼤的提⾼开发和架构设计的效率.

3.EF 跨数据⽀持的是 ORM 框架主要功能点之⼀,带来的是可以通过仅仅改变配置就可以做到跨数据库的能

⼒

2725.如何提⾼ LINQ 性能问题？

提升从数据库中拿数据的速度，可以参考以下⼏种⽅法：

1.在数据库中的表中定义合适的索引和键

2.只获得你需要的列（使⽤ ViewModel 或者改进你的查询）和⾏（使⽤ IQueryable）

3.尽可能使⽤⼀条查询⽽不是多条

4.只为了展示数据，⽽不进⾏后续修改时，可以使⽤ AsNoTracking。它不会影响⽣成的 SQL，但它可以令

系统少维护很多数据，从⽽提⾼性能

5.使⽤ Reshaper 等⼯具，它可能会在你写出较差的代码时给出提醒

26.什么是协变和逆变?

可变性是以⼀种类型安全的⽅式，将⼀个对象作为另⼀个对象来使⽤。其对应的术语则是不变性

（

invariant）。

可变性：

可变性是以⼀种类型安全的⽅式，将⼀个对象作为另⼀个对象来使⽤。例如对普通继承中的可变性：若某

⽅法声明返回类型为 Stream，在实现时可以返回⼀个 MemoryStream。可变性有两种类型：协变和逆变。

协变性：

可以建⽴⼀个较为⼀般类型的变量，然后为其赋值，值是⼀个较为特殊类型的变量。例如：

1 string str = "test";

2 // An object of a more derived type is assigned to an object of a

less derived type.

3 object obj = str;

因为 string 肯定是⼀个 object，所以这样的变化⾮常正常。

28 逆变性：在上⾯的例⼦中，我们⽆法将 str 和⼀个新的 object 对象画等号。如果强⾏要实现的话，只能这么

⼲：

1 string s = (string) new object();

但这样还是会在运⾏时出错。这也告诉我们，逆变性是很不正常的。

泛型的协变与逆变:

协变性和 out 关键字搭配使⽤，⽤于向调⽤者返回某项操作的值。例如下⾯的接⼝仅有⼀个⽅法，就是⽣产

⼀个 T 类型的实例。那么我们可以传⼊⼀个特定类型。如我们可以将 IFactory 视为 IFactory。这也适⽤于

Food 的所有⼦类型。（即将其视为⼀个更⼀般类型的实现）

1 interface IFactory<T>

2 {

3 T CreateInstance();

4 }

逆变性则相反，和 in 关键字搭配使⽤，指的是 API 将会消费值，⽽不是⽣产值。此时⼀般类型出现在参数

中：

1 interface IPrint<T>

2 {

3 void Print(T value);

4 }

这意味着如果我们实现了 IPrint< Code >，我们就可以将其当做 IPrint< CsharpCode >使⽤。（即将其视

为⼀个更具体类型的实现）

如果存在双向的传递，则什么也不会发⽣。这种类型是不变体(invariant)。

1 interface IStorage<T>

2 {

3 byte[] Serialize(T value);

4 T Deserialize(byte[] data);

295 }

这个接⼝是不变体。我们不能将它视为⼀个更具体或更⼀般类型的实现。

假设有如下继承关系 People –> Teacher，People –> Student。

如果我们以协变的⽅式使⽤（假设你建⽴了⼀个 IStorage< Teacher >的实例，并将其视为 IStorage）则

我们可能会在调⽤ Serialize 时产⽣异常，因为 Serialize ⽅法不⽀持协变（如果参数是 People 的其他⼦类，

例如 Student，则 IStorage< Teacher >将⽆法序列化 Student）。

如果我们以逆变的⽅式使⽤（假设你建⽴了⼀个 IStorage 的实例，并将其视为 IStorage< Teacher >），

则我们可能会在调⽤ Deserialize 时产⽣异常，因为 Deserialize ⽅法不⽀持逆变，它只能返回 People 不能

返回 Teacher。

27.什么是 IEnumerable？

IEnumerable 及 IEnumerable 的泛型版本 IEnumerable 是⼀个接⼝，它只含有⼀个⽅法 GetEnumerator。

Enumerable 这个静态类型含有很多扩展⽅法，其扩展的⽬标是 IEnumerable。

实现了这个接⼝的类可以使⽤ Foreach 关键字进⾏迭代（迭代的意思是对于⼀个集合，可以逐⼀取出元素

并遍历之）。实现这个接⼝必须实现⽅法 GetEnumerator。

28.IEnumerable 的缺点有哪些？

IEnumerable 功能有限，不能插⼊和删除。

访问 IEnumerable 只能通过迭代，不能使⽤索引器。迭代显然是⾮线程安全的，每次 IEnumerable 都会⽣

成新的 IEnumerator，从⽽形成多个互相不影响的迭代过程。

在迭代时，只能前进不能后退。新的迭代不会记得之前迭代后值的任何变化。

28.延迟执⾏ (Lazy Loading)是什么？

⼤部分 LINQ 语句是在最终结果的第⼀个元素被访问的时候（即在 foreach 中调⽤ MoveNext ⽅法）才真正

开始运算的，这个特点称为延迟执⾏。⼀般来说，返回另外⼀个序列（通常为 IEnumerable 或

IQueryable）的操作，使⽤延迟执⾏，⽽返回单⼀值的运算，使⽤⽴即执⾏。

30IEnumerable 是延迟执⾏的，当没有触发执⾏时，就不会进⾏任何运算。Select ⽅法不会触发 LINQ 的执

⾏。⼀些触发的⽅式是：foreach 循环，ToList，ToArray，ToDictionary ⽅法等

29.LINQ 可视化⼯具简单介绍⼀下？

LINQPad ⼯具是⼀个很好的 LINQ 查询可视化⼯具。它由 Threading in C#和 C# in a Nutshell 的作者

Albahari 编写，完全免费。它的下载地址是http://www.linqpad.net/

进⼊界⾯后，LINQPad 可以连接到已经存在的数据库（不过就仅限微软的 SQL Server 系，如果要连接到其

他类型的数据库则需要安装插件）。某种程度上可以代替 SQL Management Studio，是使⽤ SQL

Management Studio 作为数据库管理软件的码农的强⼒⼯具，可以⽤于调试和性能优化（通过改善编译后

的 SQL 规模）。

LINQPad ⽀持使⽤ SQL 或 C#语句（点标记或查询表达式）进⾏查询。你也可以通过点击橙⾊圈内的各种不

同格式，看到查询表达式的各种不同表达⽅式：

Lambda：查询表达式的 Lambda 表达式版本，

SQL：由编译器转化成的 SQL，通常这是我们最关⼼的部分，

IL：IL 语⾔

29.LINQ to Object 和 LINQ to SQL 有何区别？

LINQ to SQL 可以将查询表达式转换为 SQL 语句，然后在数据库中执⾏。相⽐ LINQ to Object，则是将查

询表达式直接转化为 Enumerable 的⼀系列⽅法，最终在 C#内部执⾏。LINQ to Object 的数据源总是实现

IEnumerable（所以不如叫做 LINQ to IEnumerable），相对的，LINQ to SQL 的数据源总是实现

IQueryable 并使⽤ Queryable 的扩展⽅法。

将查询表达式转换为 SQL 语句并不保证⼀定可以成功。

30.除了 EF，列举出你知道的 ORM 框架？

dapper EntityFramework、 EJB、Hibernate、IBATIS、TopLink、OJB

31.如何如何获取 EF ⽣成的 Sql 脚本？

1.可以调试起来通过 SqlServerProfiler 来获取 Sql

312.EF Dbcontext 注册⽇志事件输出⽇志查看 Sql

32.在哪些类型额项⽬中你会选择 EF? 为什么？

这个要结合 EF 的特点来说：EF 主要是以⾯向对象的思想来做数据库数据操作，对 Sql 语句能⼒没什么要

求，开发使⽤效率⾼！便于上⼿，⼀般来说，使⽤ EF 框架，肯定会⽐直接使⽤ ADO.NET，消耗的时间多⼀

些。 所以在⼀般企业级开发，管理型系统，对数据性能要求不是特别⾼的情况下，优先选择 EF,这样可以

⼤⼤的推进开发效率！如果像⼀些互联⽹项⽬中，对性能要求精度很⾼！可以另外做技术选型，选择原⽣

ADO.NET。

33.请说明 EF 中映射实体对象的⼏种状态？

Detached：该实体未由上下⽂跟踪。刚使⽤新运算符或某个 System.Data.Entity.DbSet Create ⽅法创

建实体后，实体就处于此状态。

Unchanged：实体将由上下⽂跟踪并存在于数据库中，其属性值与数据库中的值相同。

Added：实体将由上下⽂跟踪，但是在数据库中还不存在。

Deleted：实体将由上下⽂跟踪并存在于数据库中，但是已被标记为在下次调⽤ SaveChanges 时从数据

库中删除。

Modified：实体将由上下⽂跟踪并存在于数据库中，已修改其中的⼀些或所有属性值。

34.如果实体名称和数据库表名不⼀致，该如何处理？

实体名称和数据库表名称不⼀致：可以通过使⽤ TableAttribute 特性；

35. 泛型的优点有哪些？

代码的可重⽤性。⽆需从基类型继承，⽆需重写成员。

扩展性好。

类型安全性提⾼。 泛型将类型安全的负担从你那⾥转移到编译器。 没有必要编写代码来测试正确的数据类

型，因为它会在编译时强制执⾏。 降低了强制类型转换的必要性和运⾏时错误的可能性。

3233

性能提⾼。泛型集合类型通常能更好地存储和操作值类型，因为⽆需对值类型进⾏装箱。

会执⾏，在 return 前执⾏。

C# 异常是使⽤类来表示的，异常类主要是直接或间接地派⽣于 System.Exception 类。

System.ApplicationException 和 System.SystemException 类是派⽣于 System.Exception 类的异常

类。

System.ApplicationException 类⽀持由应⽤程序⽣成的异常，所以我们⾃⼰定义的异常都应派⽣⾃该

类。

System.SystemException 类是所有预定义的系统异常的基类。

System.IO.IOException

⽤于处理 I/O 错误(读写⽂件)。

System.IndexOutOfRangeException ⽤于处理当⽅法指向超出范围的数组索引时⽣成的错误。

System.ArrayTypeMismatchException

⽤于处理当数组类型不匹配时⽣成的错误。

System.NullReferenceException

⽤于处理当依从⼀个空对象时⽣成的错误。

System.DivideByZeroException ⽤于处理当除以零时⽣成的错误。例如：100/0 就会报这个错误。

System.InvalidCastException ⽤于处理在类型转换期间⽣成的错误。

System.OutOfMemoryException

⽤于处理空闲内存不⾜⽣成的错误。

System.StackOverflowException

⽤于处理栈溢出⽣成的错误。

泛型约束 public void GetEntity() where T:class

36.try {}⾥有⼀个 return 语句，那么紧跟在这个 try 后的 finally {}⾥的 code 会不会被执⾏，什

么时候被执⾏，在 return 前还是后?

37.C# 中的异常类有哪些？

38.泛型有哪些常⻅的约束？where T :struct //约束 T 必须为值类型

where K : class //约束 K 必须为引⽤类型

where V : IComparable //约束 V 必须是实现了 IComparable 接⼝

where W : K //要求 W 必须是 K 类型，或者 K 类型的⼦类

where X :class ,new () // 或者写出 new class() ； X 必须是引⽤类型，并且要有⼀个⽆参的构造函数

（对于⼀个类型有多有约束，中间⽤逗号隔开）

39.Collection 和 Collections 的区别？

Collection 是集合类的上级接⼝，Collections 是针对集合类的⼀个帮助类，它提供⼀系列静态⽅法来实

现对各种集合的搜索，排序，线程安全化操作。

40.能⽤ foreach 遍历访问的对象的要求？

需要实现 IEnumerable 接⼝或声明 GetEnumerator ⽅法的类型。

41.说出五个集合类？

List：泛型类；

Stack：堆栈，后进先出的访问各个元素

Dictionary<TKey, TValue>：字典类，key 是区分⼤⼩写；value ⽤于存储对应于 key 的值

HashSet：此集合类中不能有重复的⼦元素

SortedList<TKey, TValue>：排序列表，key 是排好序的数组。

42.C#可否对内存进⾏直接的操作？

C#在 Unsafe 模式下可以使⽤指针对内存进⾏操作, 但在托管模式下不可以使⽤指针。

341.在 Visual Studio 开发环境中设置/unsafe（启⽤不安全模式)编译器选项

打开项⽬的“属性”⻚。

单击“⽣成”属性⻚。

选中“允许不安全代码”复选框。

2.unsafe 关键字表示不安全上下⽂，该上下⽂是任何涉及指针的操作所必需的。

可以在类型或成员的声明中使⽤ unsafe 修饰符。

因此，类型或成员的整个正⽂范围均被视为不安全上下⽂。例如，以下是⽤ unsafe 修饰符声明的⽅法：

1 unsafe static void FastCopy(byte[] src, byte[] dst, int count)

2 {

3 // Unsafe context: can use pointers here.

4 }

不安全上下⽂的范围从参数列表扩展到⽅法的结尾，因此指针在以下参数列表中也可以使⽤：

1 unsafe static void FastCopy ( byte* ps, byte* pd, int count )

{...}

还可以使⽤不安全块从⽽能够使⽤该块内的不安全代码。例如：

1 unsafe

2 {

3 // Unsafe context: can use pointers here.

4 }

若要编译不安全代码，必须指定 /unsafe 编译器选项。

⽆法通过公共语⾔运⾏库验证不安全代码。

43.HashMap 和 Hashtable 区别？

Collection 是集合类的上级接⼝，Collections 是针对集合类的⼀个帮助类，它提供⼀系列静态⽅法来实现

对各种集合的搜索，排序，线程安全化操作。

353637

.NET/C#⾯试题汇总系列：多线程

不会发⽣死锁，（但有⼀点 int 是按值传递的，所以每次改变的都只是⼀个副本，因此不会出现死锁。但如

果把 int 换做⼀个 object，那么死锁会发⽣）

线程(Thread)与进程（

Process）⼆者都定义了某种边界，不同的是进程定义的是应⽤程序与应⽤程序之

间的边界，不同的进程之间不能共享代码和数据空间，⽽线程定义的是代码执⾏堆栈和执⾏上下⽂的边

界。⼀个进程可以包括若⼲个线程，同时创建多个线程来完成某项任务，便是多线程。

⽽同⼀进程中的不同线程共享代码和数据空间。⽤⼀个⽐喻来说，如果⼀个家庭代表⼀个进程，在家庭内

部，各个成员就是线程，家庭中的每个成员都有义务对家庭的财富进⾏积累，同时也有权利对家庭财富进

⾏消费，当⾯对⼀个任务的时候，家庭也可以派出⼏个成员来协同完成，⽽家庭之外的⼈则没有办法直接

消费不属于⾃⼰家庭的财产。

1.根据线程安全的相关知识，分析以下代码，当调⽤ test ⽅法时 i>10 时是否会引起死锁?并简

要说明理由。

1 public void test(int i)

2 {

3 lock(this)

4 {

5 if (i>10)

6 {

7 i--;

8 test(i);

9 }

10 }

11 }

2.描述线程与进程的区别？

3.Windows 单个进程所能访问的最⼤内存量是多少？它与系统的最⼤虚拟内存⼀样吗？这对

于系统设计有什么影响？这个需要针对硬件平台，公式为单个进程能访问的最⼤内存量=2 的处理器位数次⽅/2，⽐如通常情况下，

32 位处理器下，单个进程所能访问的最⼤内存量为:232 /2 = 2G 。单个进程能访问的最⼤内存量是最⼤

虚拟内存的 1/2，因为要分配给操作系统⼀半虚拟内存。

4.using() 语法有⽤吗？什么是 IDisposable？

有⽤，实现了 IDisposiable 的类在 using 中创建，using 结束后会⾃定调⽤该对象的 Dispose ⽅法，释放资

源。

5.前台线程和后台线程有什么区别？

通过将 Thread.IsBackground 属性设置为 true，就可以将线程指定为后台线程

前台线程： 应⽤必须结束掉所有的前台线程才能结束程序，只要有⼀个前台线程没退出进程就不会⾃动退

出，当然线程是依附在进程上的，所以你直接把进程 KO 掉了的话⾃然所有前台线程也会退出。

后台线程： 进程可以不考虑后台直接⾃动退出，进程⾃动退出后所有的后台线程也会⾃动销毁。

6.什么是互斥？

当多个线程访问同⼀个全局变量，或者同⼀个资源(⽐如打印机)的时候，需要进⾏线程间的互斥操作来保证

访问的安全性。

7.如何查看和设置线程池的上下限？

线程池的线程数是有限制的，通常情况下，我们⽆需修改默认的配置。但在⼀些场合，我们可能需要了解

线程池的上下限和剩余的线程数。线程池作为⼀个缓冲池，有着其上下限。在通常情况下，当线程池中的

线程数⼩于线程池设置的下限时，线程池会设法创建新的线程，⽽当线程池中的线程数⼤于线程池设置的

上限时，线程池将销毁多余的线程。

PS：在.NET Framework 4.0 中，每个 CPU 默认的⼯作者线程数量最⼤值为 250 个，最⼩值为 2 个。⽽ IO

线程的默认最⼤值为 1000 个，最⼩值为 2 个。

在.NET 中，通过 ThreadPool 类型提供的 5 个静态⽅法可以获取和设置线程池的上限和下限，同时它还额

外地提供了⼀个⽅法来让程序员获知当前可⽤的线程数量，下⾯是这五个⽅法的签名：

① static void GetMaxThreads(out int workerThreads, out int completionPortThreads)

38② static void GetMinThreads(out int workerThreads, out int completionPortThreads)

③ static bool SetMaxThreads(int workerThreads, int completionPortThreads)

④ static bool SetMinThreads(int workerThreads, int completionPortThreads)

⑤ static void GetAvailableThreads(out int workerThreads, out int completionPortThreads)

8. Task 状态机的实现和⼯作机制是什么？

CPS 全称是 Continuation Passing Style，在.NET 中，它会⾃动编译为： 1. 将所有引⽤的局部变量做成

闭包，放到⼀个隐藏的状态机的类中； 2. 将所有的 await 展开成⼀个状态号，有⼏个 await 就有⼏个状态

号； 3. 每次执⾏完⼀个状态，都重复回调状态机的 MoveNext ⽅法，同时指定下⼀个状态号； 4.

MoveNext ⽅法还需处理线程和异常等问题。

9.await 的作⽤和原理，并说明和 GetResult()有什么区别？

从状态机的⻆度出发，await 的本质是调⽤ Task.GetAwaiter()的 UnsafeOnCompleted(Action)回调，并

指定下⼀个状态号。

从多线程的⻆度出发，如果 await 的 Task 需要在新的线程上执⾏，该状态机的 MoveNext()⽅法会⽴即返

回，此时，主线程被释放出来了，然后在 UnsafeOnCompleted 回调的 action 指定的线程上下⽂中继续

MoveNext()和下⼀个状态的代码。

⽽相⽐之下，GetResult()就是在当前线程上⽴即等待 Task 的完成，在 Task 完成前，当前线程不会释放。

注意：Task 也可能不⼀定在新的线程上执⾏，此时⽤ GetResult()或者 await 就只有会不会创建状态机的区

别了。

10.Task 和 Thread 有区别吗？

Task 和 Thread 都能创建⽤多线程的⽅式执⾏代码，但它们有较⼤的区别。Task 较新，发布于.NET 4.5，

能结合新的 async/await 代码模型写代码，它不⽌能创建新线程，还能使⽤线程池（默认）、单线程等⽅

式编程，在 UI 编程领域，Task 还能⾃动返回 UI 线程上下⽂，还提供了许多便利 API 以管理多个 Task。

11.多线程有什么⽤？

39（

1）发挥多核 CPU 的优势

随着⼯业的进步，现在的笔记本、台式机乃⾄商⽤的应⽤服务器⾄少也都是双核的，4 核、8 核甚⾄ 16 核的

也都不少⻅，如果是单线程的程序，那么在双核 CPU 上就浪费了 50%，在 4 核 CPU 上就浪费了 75%。单核

CPU 上所谓的”多线程”那是假的多线程，同⼀时间处理器只会处理⼀段逻辑，只不过线程之间切换得⽐较

快，看着像多个线程”同时”运⾏罢了。多核 CPU 上的多线程才是真正的多线程，它能让你的多段逻辑同时

⼯作，多线程，可以真正发挥出多核 CPU 的优势来，达到充分利⽤ CPU 的⽬的。

（

2）防⽌阻塞

从程序运⾏效率的⻆度来看，单核 CPU 不但不会发挥出多线程的优势，反⽽会因为在单核 CPU 上运⾏多线

程导致线程上下⽂的切换，⽽降低程序整体的效率。但是单核 CPU 我们还是要应⽤多线程，就是为了防⽌

阻塞。试想，如果单核 CPU 使⽤单线程，那么只要这个线程阻塞了，⽐⽅说远程读取某个数据吧，对端迟

迟未返回⼜没有设置超时时间，那么你的整个程序在数据返回回来之前就停⽌运⾏了。多线程可以防⽌这

个问题，多条线程同时运⾏，哪怕⼀条线程的代码执⾏读取数据阻塞，也不会影响其它任务的执⾏。

（

3）便于建模

这是另外⼀个没有这么明显的优点了。假设有⼀个⼤的任务 A，单线程编程，那么就要考虑很多，建⽴整个

程序模型⽐较麻烦。但是如果把这个⼤的任务 A 分解成⼏个⼩任务，任务 B、任务 C、任务 D，分别建⽴程

序模型，并通过多线程分别运⾏这⼏个任务，那就简单很多了。

12. 两个线程交替打印 0~100 的奇偶数

这道题就是说有两个线程，⼀个名为偶数线程，⼀个名为奇数线程，偶数线程只打印偶数，奇数线程只打

印奇数，两个线程按顺序交替打印。

1 publicclassThreadExample

2 {

3 ///<summary>

4 ///两个线程交替打印 0~100 的奇偶数

5 ///</summary>

6 public static void PrintOddEvenNumber

7 {

8 varwork = newTheadWorkTest;

9 varthread1 = newThread(work.PrintOddNumer) { Name = "奇数线程"};

10 varthread2 = newThread(work.PrintEvenNumber) { Name = "偶数线

程"};

4011 thread1.Start;

12 thread2.Start;

13 }

14 }

15

16 publicclassTheadWorkTest

17 {

18

19 privatestaticreadonlyAutoResetEvent oddAre = newAutoResetEvent(

false);

20

21 privatestaticreadonlyAutoResetEvent evenAre = newAutoResetEvent

( false);

22

23 publicvoidPrintOddNumer

24 {

25 oddAre.WaitOne;

26 for( var0; i < 100; i++ )

27 {

28 if(i % 2!= 1) continue;

29 Console.WriteLine($"{Thread.CurrentThread.Name}：{i}");

30 evenAre.Set;

31 oddAre.WaitOne;

32 }

33 }

34

35 publicvoidPrintEvenNumber

36 {

37 for( vari = 0; i < 100; i++ )

38 {

39 if(i % 2!= 0) continue;

40 Console.WriteLine($"{Thread.CurrentThread.Name}：{i}");

41 oddAre.Set;

42 evenAre.WaitOne;

43 }

44 }

45 }

13.为什么 GUI 不⽀持跨线程调⽤?有什么解决⽅法？

41 因为 GUI 应⽤程序引⼊了⼀个特殊的线程处理模型，为了保证 UI 控件的线程安全，这个线程处理模型不允许

其他⼦线程跨线程访问 UI 元素。解决⽅法⽐较多的：

利⽤ UI 控件提供的⽅法，Winform 是控件的 Invoke ⽅法，WPF 中是控件的 Dispatcher.Invoke ⽅法；

使⽤ BackgroundWorker；

使⽤ GUI 线程处理模型的同步上下⽂ SynchronizationContext 来提交 UI 更新操作

14.说说常⽤的锁，lock 是⼀种什么样的锁？

常⽤的如如 SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，lock 是⼀个混

合锁，其实质是 Monitor

15.lock 为什么要锁定⼀个参数（可否为值类型？）参数有什么要求？

lock 的锁对象要求为⼀个引⽤类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不⼀

样，会导致锁定⽆效。

对于 lock 锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向⼀个真正的锁（同步

块），这个锁（同步块）会被复⽤。

16.多线程和异步的区别和联系?

多线程是实现异步的主要⽅式之⼀，异步并不等同于多线程。实现异步的⽅式还有很多，⽐如利⽤硬件的

特性、使⽤进程或纤程等。

在.NET 中就有很多的异步编程⽀持，⽐如很多地⽅都有 Begin*、End* 的⽅法，就是⼀种异步编程⽀持，她

内部有些是利⽤多线程，有些是利⽤硬件的特性来实现的异步编程。

17.线程池的有点和不⾜?

优点：减⼩线程创建和销毁的开销，可以复⽤线程；也从⽽减少了线程上下⽂切换的性能损失；在 GC 回收

时，较少的线程更有利于 GC 的回收效率。缺点：线程池⽆法对⼀个线程有更多的精确的控制，如了解其运

⾏状态等；不能设置线程的优先级；加⼊到线程池的任务（⽅法）不能有返回值；对于需要⻓期运⾏的任

务就不适合线程池。

4218.Mutex 和 lock 有什么不同？⼀般⽤哪⼀种⽐较好？

Mutex 是⼀个基于内核模式的互斥锁，⽀持锁的递归调⽤，⽽ Lock 是⼀个混合锁，⼀般建议使⽤ Lock 更

好，因为 lock 的性能更好。

19.⽤双检锁实现⼀个单例模式 Singleton。

1 public static class Singleton<T> where T : class,new()

2 {

3 private static T \_Instance;

4 private static object \_lockObj = new object();

5

6 /// <summary>

7 /// 获取单例对象的实例

8 /// </summary>

9 public static T GetInstance()

10 {

11 if (\_Instance != null) return \_Instance;

12 lock (\_lockObj)

13 {

14 if (\_Instance == null)

15 {

16 var temp = Activator.CreateInstance<T>();

17 System.Threading.Interlocked.Exchange(ref \_In

stance, temp);

18 }

19 }

20 return \_Instance;

21 }

22 }

20.Thread 类有哪些常⽤的属性和⽅法？

属性：

CurrentContext：获取线程正在其中执⾏的当前上下⽂。

43CurrentCulture：获取或设置当前线程的区域性。

CurrentPrincipal：获取或设置线程的当前负责⼈（对基于⻆⾊的安全性⽽⾔）。

CurrentThread：获取当前正在运⾏的线程。

CurrentUICulture：获取或设置资源管理器使⽤的当前区域性以便在运⾏时查找区域性特定的资源。

IsBackground：获取或设置⼀个值，该值指示某个线程是否为后台线程。

Priority：获取或设置⼀个值，该值指示线程的调度优先级。

ThreadState：获取⼀个值，该值包含当前线程的状态。

⽅法：

public void Abort()

在调⽤此⽅法的线程上引发 ThreadAbortException，以开始终⽌此线程的过程。调⽤此⽅法通常会终⽌

线程。

1 public static void ResetAbort()

取消为当前线程请求的 Abort。

public void Start()

开始⼀个线程。

1 public static void Sleep( int millisecondsTimeout )

让线程暂停⼀段时间。

1 public static bool Yield()

导致调⽤线程执⾏准备好在当前处理器上运⾏的另⼀个线程。由操作系统选择要执⾏的线程。

4445.NET/C#⾯试题汇总系列：ASP.NET MVC

1.MVC 中的 TempData\ViewBag\ViewData 区别?

TempData 保存在 Session 中，Controller 每次执⾏请求的时候，会从 Session 中先获取 TempData，⽽

后清除 Session，获取完 TempData 数据，虽然保存在内部字典对象中，但是其集合中的每个条⽬访问⼀次

后就从字典表中删 除，ViewData 存的是 Key/Value 字典，使⽤时需要类型转换。

ViewBag 和 ViewData 只在当前 Action 中有效，等同于 View，ViewBag ⽐ ViewData 慢，ViewBag 存

dynamic 类型数据，使⽤时不需要类型转换

ViewData 和 ViewBag 中的值可以互相访问，因为 ViewBag 的实现中包含了 ViewData，ViewData 存的是

Key/Value 字典，使⽤时需要类型转换

2.阐述下 MVC 框架的机制，各个模块的作⽤?

所谓模型，就是 MVC 需要提供的数据源，负责数据的访问和维护。

所谓视图，就是⽤于显示模型中数据的⽤户界⾯。

所谓控制器，就是⽤来处理⽤户的输⼊，负责改变模型的状态并选择适当的视图来显示模型的数据。

3.ASP.NET 和 ASP.NET MVC 的关系?

ASP.NET MVC 是在核⼼ ASP.NET 基础之上构建的，从 mvc 命名空间 System.Web.Mvc 就能看出，因为

System.Web 是 Asp.NET 的核⼼命名空间。

⽐如 ASP.NET MVC 依赖于 HttpHandler，关于请求是怎么进⼊控制器的，其实就是⽤到了 HttpHandler

Session、Cookie、Cache 和 Application 这些 ASP.NET 的对象保存机制在 MVC 中依然是需要⽤到的

HttpContext、Request、Response、Server 对象在 MVC 中仍然可以使⽤，在 Controller 中通过智能感知

的形式很容易得到这些对象

4. MVC 对 ASP.NET 好处在哪⾥？

46 提供⾮常清晰的成绩管理，像 ui 层，也就是 view, 数据层 model 和管理层 controller。

单元测试⽐较容易。

改善了数据模型和视图的重⽤性。

代码的结构更加优化。

5.什么是 razor view engine?

这个引擎提供了数据绑定的显示模板。

1 @model MvcStore.Models.Customer

2

3 @{ViewBag.Title="Get Customers";}

4

5 <div class="cust"><h3><em>@Model.CustomerName</em></h3></div>

6.view bag 和 view data 之间的区别是什么？

view bag 是 view data 的⼀个扩展。扩展以后可以创建动态的属性。这样的好处有:

不需要进⾏类型的转换。

我们可以使⽤ dynamic 关键字。

但是有⼀个缺点就是 view bag 要⽐ view data 慢⼀些。

7.解释⼀下 sections?

Sections 是 html ⻚⾯的⼀部分。

1 @rendersection("testsection")

47 在⼦⻚⾯中我们定义如下的 sections。

1 @section testsection {

2 <h1>test content</h1>

3 }

如果这个 section 没有定义的话会出错，我们可以使⽤⼀个 required 属性来防⽌⻚⾯出错。

1 @rendersection("testsection", required: false)

8.为什么要使⽤ html.partial？

这个⽅法⽤来显示 html string 指定的某块视图。

1 html.partial("testpartialview")

9.什么是 partial view？

Partial view 相当于传统⽹⻚表格中的 user controls.

它的主要⽬的是为了重复使⽤这些视图，他们⼀般被放在⼀个共享⽂件夹⾥⾯。

1 html.partial()

2

3 html.renderpartial()

10.MVC 同时适⽤于 Windows 应⽤和 Web 应⽤吗?

相⽐ Windows 应⽤，MVC 架构更适⽤于 Web 应⽤。对于 Windows 应⽤，MVP(Model View Presenter )

架构更好⼀点。如果你使⽤ WPF 和 Silverlight，MVVM 更适合。

11.在 MVC 中如何保持 Sessions?

48 可以通过三种⽅式保持： tempdata, viewdata, 和 viewbag。

12.已经有了 ASPX，为什么还要 Razor?

相⽐ ASPX，Razor 是⼀个⼲净的、轻量级的和语法更简单。例如，ASPX 去显示时间：

1 <%=DateTime.Now%>

在 Razor 中，只需要⼀⾏：

1 @DateTime.Now

13.在 MVC 中如何去执⾏ Windows 认证？

你需要修改 web.config ⽂件，并设置验证模式为 Windows。

1 <authentication mode="Windows"/>

2 <authorization>

3 <deny users="?"/>

4 </authorization>

然后在 controlle 或 action 中，你可以使⽤ Authorize 属性，指定哪个⽤户可以访问这个 controller 或

action。下⾯的代码设置到只有指定的⽤户可以访问它。

1 [Authorize(Users= @"WIN-3LI600MWLQN\Administrator")]

2 public class StartController : Controller

3 {

4 //

5 // GET: /Start/

6 [Authorize(Users = @"WIN-3LI600MWLQN\Administrator")]

7 public ActionResult Index()

8 {

499 return View("MyView");

10 }

11 }

14.在 MVC 中如何⽤表单认证？

表单认证和 ASP.NET 的表单验证⼀样。第⼀步是设置认证模式为 Forms。loginUrl 是指向到 controller，⽽

不是⼀个⻚⾯。

1 <authentication mode="Forms">

2 <forms loginUrl="~/Home/Login" timeout="2880"/>

3 </authentication>

我们也需要创建⼀个 controller，去验证⽤户。如果验证通过，需要设置 cookies 值。

1 public ActionResult Login()

2 {

3 if ((Request.Form["txtUserName"] == "Shiv") &&

4 (Request.Form["txtPassword"] == "Shiv@123"))

5 {

6 FormsAuthentication.SetAuthCookie("Shiv",true);

7 return View("About");

8 }

9 else

10 {

11 return View("Index");

12 }

13 }

其它需要验证的 action 都需要加⼀个 Authorize 属性，如果⽤户没权限将转向到登陆⻚⾯。

1 [Authorize]

2 PublicActionResult Default()

3 {

4 return View();

505 }

6 [Authorize]

7 publicActionResult About()

8 {

9 return View();

10 }

15.MVC 有多少种不同类型的结果类型？

注意： 很难去记住所有的 12 种类型。但是⼀些重要的你可以记住，例如： ActionResult ， ViewResult

，和 JsonResult 。详情如下:

MVC 中的 12 种结果类型，最主要的是 ActionResult 类，它是⼀个基础类，它有 11 个⼦类型，如下：

ViewResult - 给响应流渲染指定的视图

PartialViewResult - 给响应流渲染指定的局部视图

EmptyResult - 返回空的响应结果。

RedirectResult - 执⾏⼀个 HTTP 转向到指定的 URL。

RedirectToRouteResult - 执⾏⼀个 HTTP 转向到⼀个 URL，这个 URL 由基于路由数据的路由引擎来决定

JsonResult - 序列化⼀个 ViewData 对像到 JSON 格式。

JavaScriptResult - 返回⼀段 Javascript 代码，它可以在客户端执⾏。

ContentResult - 写内容到响应流，不需要视图⽀持。

FileContentResult - 返回⼀个⽂件到客户端。

FileStreamResult - 返回⼀个⽂件到客户端，它提供的是流。

FilePathResult - 返回⼀个⽂件到客户端。

16.什么是 WebAPI?

51HTTP 是最常⽤的协议。过去的很多年，浏览器是我们使⽤ HTTP ⽅式公开数据的⾸选客户端。但是⽇新⽉

异，客户端发展到多种形式。我们需要使⽤ HTTP ⽅式传递数据给不同的客户端，例如：移动⼿机、

Javascript，Windows 应⽤等等。

WebAPI 是⼀个通过 HTTP ⽅式公开数据的技术，它跟随 REST 规则。

17.什么是 MVC 中的打包也压缩?

打包与压缩帮助我们减少⼀个⻚⾯的请求时间，从⽽提⾼⻚⾯执⾏性能。

打包如何搞⾼性能？

我们的项⽬总是需要 CSS 和脚本⽂件。打包帮助你合并多个 Javascript 和 css ⽂件到单个⽂件，从⽽最⼩化

多个请求到⼀个请求。

例如，包含下⾯的 web 请求到⼀个⻚。这个⻚⾯要求两个 Javascript ⽂件， Javascript1.js 和

Javascript2.js 。

18.简述 Func 与 Action 的区别？

Func 是有返回值的委托，Action 是没有返回值的委托。

19.在项⽬中如何解决⾼并发问题？

答案：尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交

互，提⾼性能。

优化数据库查询语句。

优化数据库结构，多做索引，提⾼查询效率。

统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。

能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态 html 来显示）。

解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。

5253

如果你要去检查字符的⻓度，你可以使⽤ StringLength

如果你想使⽤注册表达式，你可以使⽤ RegularExpression 。

如果你想检查数字是否在⼀个范围内，你可以使⽤ Range 。

有时你想⽐较两个字段的值，我们可以使⽤ Compare。

ActionResult 是⼀个抽象类，ViewResult 衍⽣于 ActionResult 类。 ActionResult 有⼏种衍⽣类，例

如： ViewResult，JsonResult，FileStreamResult， 等等。

ActionResult 可以⽤来开发多态和动态动象。所以如果你动态运⾏不同类型的视图，ActionResult 是最

好的选择。例如下⾯的代码，你可以看⻅我们有⼀个 DynamicView。基于标记（

IsHtmlView），它会返回

ViewResult 或 JsonResult。

19.MVC 中还有哪些注释属性⽤来验证？

1 [StringLength(160)]

2 public string FirstName { get; set; }

1 [RegularExpression(@"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,

4}")]public string Email { get; set; }

1 [Range(10,25)]public int Age { get; set; }

1 public string Password { get; set; }

2 [Compare("Password")]

3 public string ConfirmPass { get; set; }

20.ActionResult 和 ViewResult 有什么不同?

21.MVC 中如何执⾏打包？打开 App_Start ⽂件夹中的 BundleConfig.cs

在 BundleConfig.cs 中，添加你想打包的 JS ⽂件路径到打包集合。如下所示：

1 bundles.Add(new ScriptBundle("~/Scripts/MyScripts").Include(

2 "~/Scripts/\*.js"));

下⾯是 BundleConfig.cs ⽂件的代码：

1 public class BundleConfig

2 {

3 public static void RegisterBundles(BundleCollection bundles)

4 {

5 bundles.Add(new ScriptBundle("~/Scripts/MyScripts").Includ

e(

6 "~/Scripts/\*.js"));

7 BundleTable.EnableOptimizations = true;

8 }

9 }

⼀旦你合并了脚本到⼀个⽂件，你可以使⽤下⾯的代码去调⽤它：

1 <%= Scripts.Render("~/Scripts/MyScripts") %>

22.MVC 的路由选择是什么?

路由选择功能帮你定义⼀个 URL 规则，映射 URL 到控制器。

23.在哪⾥写路由映射表？

在 “global.asax” ⽂件。

24.在 MVC 中提到 Area 的好处?

54 在 MVC 中 Area 的好处如下：

它允许我们将模型、视图和控制器组织成应⽤程序的单独功能部分，如管理、计费，客户⽀持和更多。

很容易与另⼀个创建的其他区域集成。

也很容易进⾏单元测试。

25.你能解释⼀下 MVC 中的 RenderBody 和 RenderPage 吗？

RenderBody 就像 web 表单中的 ContentPlaceHolder。这将存在于布局⻚中，并将呈现⼦⻚/视图。布局

⻚将只有⼀个 RenderBody（）⽅法。RenderPage 也存在于布局⻚中，多个 RenderPage（）可以存在于

布局⻚中。

26. ASP.NET MVC 的过滤器有哪些？

APS.NET MVC 中（以下简称“MVC”）的每⼀个请求，都会分配给相应的控制器和对应的⾏为⽅法去处

理，⽽在这些处理的前前后后如果想再加⼀些额外的逻辑处理。这时候就⽤到了过滤器。

MVC ⽀持的过滤器类型有四种，分别是：Authorization(授权),Action（⾏为）,Result（结果）和

Exception（异常）。

Authorization：此类型（或过滤器）⽤于限制进⼊控制器或控制器的某个⾏为⽅法。

Exception：⽤于指定⼀个⾏为，这个被指定的⾏为处理某个⾏为⽅法或某个控制器⾥⾯抛出的异常。

Action：⽤于进⼊⾏为之前或之后的处理。

Result：⽤于返回结果的之前或之后的处理。

55.NET/C# ⾯试题汇总系列：ASP.NET Core

1.如何在 controller 中注⼊ service?

在 config services ⽅法中配置这个 service。

在 controller 的构造函数中，添加这个依赖注⼊。

2.谈⼀谈对 DDD 的理解?

DDD，领域驱动设计。就是通过领域来指导软件设计，是⼀种⼗分抽象的软件设计思想，它主要分为战略

设计和战术设计

战略⽅⾯，通过事件⻛暴进⾏领域模型的划分，划分出核⼼域，⼦域，⽀撑域，定义通⽤语⾔，划分出界

限上下⽂。

在战术设计⽅⾯，ddd 将架构分层，“松耦合，⾼内聚”是架构设计的整体思想。按照 DDD 思想，可以分为

领域层，基础设施层，应⽤层，接⼝层。

接⼝层为前端⽤户提供 api 接⼝。基础设施层可以放⼀些第三⽅的服务，数据库连接等内容。应⽤层是对领

域服务的编排，是很薄的⼀层（⽬前我⾃⼰的架构，应⽤的是 cqrs，所有的相关逻辑都是放在了应⽤层，

⽽领域层只是放了实体，因为暂时还不是特别理解领域层的服务和事件都应该写什么）。领域层包括实

体，值对象，聚合根，领域服务，领域事件等内容。

3.ASP.NET Core ⽐ ASP.NET 更具优势的地⽅是什么？

跨平台，ASP.NET Core 可以运⾏在 Windows 、Linux 和 MAC 系统上；

对框架本安装没有依赖，所有依赖都跟程序本身在⼀起；

ASP.NET Core 处理请求的效率更⾼，进⽽可以处理更多的请求；

ASP.NET Core 具有更多的安装配置⽅法。

4.asp.net core 主要的特性有哪些？

56 依赖注⼊。

⽇志系统架构。

引⼊了⼀个跨平台的⽹络服务器，kestrel。可以没有 iis, apache 和 nginx 就可以单独运⾏。

可以使⽤命令⾏创建应⽤。

使⽤ AppSettings.json 来配置⼯程。

使⽤ start up 来注册服务。

更好的⽀持异步编程。

⽀持 web socket 和 signal IR。

对于跨⽹站的请求的预防和保护机制。

5.ASP.NET Core Filter 如何⽀持依赖注⼊?

可以通过全局注册，⽀持依赖注⼊

通过 TypeFilter(typeof(Filter)) 标记在⽅法，标记在控制器

通过 ServiceType(typeof(Filter))标记在⽅法，标记在控制器，必须要注册 Filter 这类；

TypeFilter 和 ServiceType 的本质是实现了⼀个 IFilterFactory 接⼝；

6. Asp.Net Core 中有哪些异常处理的⽅案？

1.继承 Controller，重写 OnActionExecuted

默认都会继承⼀个 Controller 类，重写 OnActionExecuted，添加上异常处理即可。⼀般情况下我们会新建

⼀个 BaseController, 让所有 Controller 继承 BaseController。代码如下

1 public class BaseController : Controller

2 {

573 public override void OnActionExecuted(ActionExecutedContext c

ontext)

4 {

5 var exception = context.Exception;

6 if (exception != null)

7 {

8 context.ExceptionHandled = true;

9 context.Result = new ContentResult

10 {

11 Content = $"BaseController 错误 : { exception.Messa

ge }"

12 };

13 }

14 base.OnActionExecuted(context);

15 }

16 }

2.使⽤ ActionFilterAttribute。

ActionFilterAttribute 是⼀个特性，本身实现了 IActionFilter 及 IResultFilter , 所以不管是 action ⾥抛

错，还是 view ⾥抛错，理论上都可以捕获。我们新建⼀个 ExceptionActionFilterAttribute, 重写

OnActionExecuted 及 OnResultExecuted，添加上异常处理，完整代码如下:

1 public class ExceptionActionFilterAttribute:ActionFilterAttribute

2 {

3 public override void OnActionExecuted(ActionExecutedContext c

ontext)

4 {

5 var exception = context.Exception;

6 if (exception != null)

7 {

8 context.ExceptionHandled = true;

9 context.Result = new ContentResult

10 {

11 Content = $"错误 : { exception.Message }"

12 };

13 }

14 base.OnActionExecuted(context);

5815 }

16

17 public override void OnResultExecuted(ResultExecutedContext c

ontext)

18 {

19 var exception = context.Exception;

20 if (exception != null)

21 {

22 context.ExceptionHandled = true;

23 context.HttpContext.Response.WriteAsync($"错误 : {exce

ption.Message}");

24 }

25 base.OnResultExecuted(context);

26 }

27 }

使⽤⽅式有两种，

在 controller ⾥打上 [TypeFilter(typeof(ExceptionActionFilter)] 标签;

在 Startup ⾥以 filter ⽅式全局注⼊。

1 services.AddControllersWithViews(options =>

2 {

3 options.Filters.Add<ExceptionActionFilterAttribute>();

4 })

3.使⽤ IExceptionFilter

我们知道, Asp.Net Core 提供了 5 类 filter, IExceptionFilter 是其中之⼀，顾名思义，这就是⽤来处理异常

的。Asp.net Core 中 ExceptionFilterAttribute 已经实现了 IExceptionFilter，所以我们只需继承

ExceptionFilterAttribute，重写其中⽅法即可。 同样新建 CustomExceptionFilterAttribute 继承

ExceptionFilterAttribute，重写 OnException ，添加异常处理，完整代码如下：

1 public class CustomExceptionFilterAttribute : ExceptionFilterAttri

bute

2 {

3 public override void OnException(ExceptionContext context)

4 {

595 context.ExceptionHandled = true;

6 context.HttpContext.Response.WriteAsync($"CustomExceptionF

ilterAttribute 错误:{context.Exception.Message}");

7 base.OnException(context);

8 }

9 }

4.使⽤ ExceptionHandler.

在 startup ⾥，vs 新建的项⽬会默认加上.

1 if (env.IsDevelopment())

2 {

3 app.UseDeveloperExceptionPage();

4 }

5 else

6 {

7 app.UseExceptionHandler("/Home/Error");

8 }

5.⾃定义 Middleare 处理

通过 middleware 全局处理。

1 public class ErrorHandlingMiddleware

2 {

3 private readonly RequestDelegate next;

4

5 public ErrorHandlingMiddleware(RequestDelegate next)

6 {

7 this.next = next;

8 }

9

10 public async Task Invoke(HttpContext context)

11 {

12 try

13 {

6014 await next(context);

15 }

16 catch (System.Exception ex)

17 {

18 //处理异常

19 }

20 }

21 }

7.介绍 ASP.NET Core 中服务的⽣命周期？

ASP.NET Core ⽀持依赖注⼊软件设计模式，它允许在不同的组件中注⼊我们的服务，并且控制服务的初

始化。有些服务可以在短时间内初始化，并且只能在某个特别的组件，以及请求中才能⽤到；⽽还有⼀些

服务，仅仅只⽤初始化⼀次，就可以在整个应⽤程序中使⽤。

Singleton --单例模式：

只有⼀个服务的实例被创建，这个实例，存储在内存中，可以在整个应⽤程序中使⽤。我们可以对⼀些初

始化代价⽐较⼤的服务，使⽤ Singleton 模式。在代码中可以这样：

1 services.AddSingleton<IProductService, ProductService>();

Scoped --作⽤域

这种模式下，将会为每⼀个请求，都创建⼀个服务的实例。所有同⼀个请求中的中间件、MVC 控制器，等

等，都会得到⼀个相同的服务实例。Entity Framework Context 就是⼀个 Scoped 服务最好的参考例⼦。

我们可以通过使⽤ AddScoped ⽅法来使⽤ Scoped 模式：

1 services.AddScoped<IProductService, ProductService>();

Transient --短暂的、瞬变的

Transient 模式下，服务每次被请求的时候，都会创建⼀个服务实例，这种模式特别适合轻量级、⽆状态的

服务。我们可以使⽤ AddTransient ⽅法，来注⼊服务：

1 services.AddTransient<IProductService, ProductService>();

6162

依赖注⼊是⼀个过程，就是当⼀个类需要调⽤另⼀个类来完成某项任务的时候，在调⽤类⾥⾯不要去 new

被调⽤的类的对象，⽽是通过注⼊的⽅式来获取这样⼀个对象。具体的实现就是在调⽤类⾥⾯有⼀个被调

⽤类的接⼝，然后通过调⽤接⼝的函数来完成任务。⽐如 A 调⽤ B，⽽ B 实现了接⼝ C，那么在 A ⾥⾯⽤ C 定

义⼀个变量 D，这个变量的实例不在 A ⾥⾯创建，⽽是通过 A 的上下⽂来获取。这样做的好处就是将类 A 和 B

分开了，他们之间靠接⼝ C 来联系，从⽽实现对接⼝编程。

setter 注⼊：

就是在类 A ⾥⾯定义⼀个 C 接⼝的属性 D，在 A 的上下⽂通过 B 实例化⼀个对象，然后将这个对象赋值给属性

D。主要就是 set 与 get

构造函数注⼊：

就是在创建 A 的对象的时候，通过参数将 B 的对象传⼊到 A 中。

还有常⽤的注⼊⽅式就是⼯⼚模式的应⽤了，这些都可以将 B 的实例化放到 A 外⾯，从⽽让 A 和 B 没有关系。

还有⼀个接⼝注⼊，就是在客户类（

A）的接⼝中有⼀个服务类(B)的属性。在实例化了这个接⼝的⼦类

后，对这个属性赋值，这和 setter 注⼊⼀样。

接⼝注⼊

相⽐构造函数注⼊和属性注⼊，接⼝注⼊显得有些复杂，使⽤也不常⻅。具体思路是先定义⼀个接⼝，包

含⼀个设置依赖的⽅法。然后依赖类，继承并实现这个接⼝。

控制反转（

Inversion of Control，缩写为 IoC），是⾯向对象编程中的⼀种设计原则，可以⽤来减低计算

机代码之间的耦合度。其中最常⻅的⽅式叫做依赖注⼊（Dependency Injection，简称 DI），还有⼀种⽅

式叫“依赖查找”（Dependency Lookup）。

通过控制反转，对象在被创建的时候，由⼀个调控系统内所有对象的外界实体将其所依赖的对象的引⽤传

递给它。也可以说，依赖被注⼊到对象中。

8.什么是依赖注⼊？

9.依赖注⼊有哪⼏种⽅式？

10.控制反转是什么？11.依赖注⼊有哪些著名的框架？

Unity、autofac、http://spring.net、MEF、Injection、Asp.Net Core 的 ServiceCollection。

12.介绍⼀些 ABP.NEXT？

ASP.NET Boilerplate 是.Net 平台⾮常优秀的⼀个开源 Web 应⽤程序框架,在国内也有⼤量的粉丝.

从名称可以看出来, 这是 ASP.NET Boilerplate 的下⼀代框架。

ABP 框架创作于 2013 年，那时候没有.Net Core 和 ASP.NET Core，也没有 Angular2 +。ABP 发布后，它

们都是从头开发的。

ASP.NET Core 引⼊了许多内置解决⽅案（扩展库），⽤于依赖注⼊，⽇志记录，缓存，本地化，配置

等。它们实际上独⽴于 ASP.NET Core，可⽤于任何类型的应⽤程序。

13.什么是 dot net core 的 startup class？

Startup class 是 dot net core 应⽤的⼊⼝。所有的 dot net core 应⽤必须有这个 class。这个类⽤来配置

应⽤。这个类的调⽤是在 program main 函数⾥⾯进⾏配置的。类的名字可以⾃⼰定义。

14.startup class 的 configure ⽅法有什么作⽤？

这个⽅法来定义整个应⽤如何响应 HTTP 请求。它有⼏个⽐较重要的参数，application builder，Hosting

environment, logo factory， 在这⾥我们可以配置⼀些中间件⽤来处理路径，验证和 session 等等。

15.什么是中间件（Middleware）？

中间件是组装到应⽤程序管道中以处理请求和响应的软件。 每个组件：

选择是否将请求传递给管道中的下⼀个组件。

可以在调⽤管道中的下⼀个组件之前和之后执⾏⼯作。

请求委托（Request delegates）⽤于构建请求管道，处理每个 HTTP 请求。

63 请求委托使⽤ Run，Map 和 Use 扩展⽅法进⾏配置。单独的请求委托可以以内联匿名⽅法（称为内联中间

件）指定，或者可以在可重⽤的类中定义它。这些可重⽤的类和内联匿名⽅法是中间件或中间件组件。请

求流程中的每个中间件组件都负责调⽤流⽔线中的下⼀个组件，如果适当，则负责链接短路。

16.中间件的使⽤场景有哪些？

份验证，Session 存储，⽇志记录等。其实我们的 Asp.net core 项⽬中本身已经包含了很多个中间件。⽐

如 身份认证中间件 UseAuthorization()等系列

17.列举官⽅常⽤的中间件？

异常/错误处理 当应⽤在开发环境中运⾏时： 开发⼈员异常⻚中间件 (UseDeveloperExceptionPage) 报

告应⽤运⾏时错误。 数据库错误⻚中间件报告数据库运⾏时错误。 当应⽤在⽣产环境中运⾏时： 异常处

理程序中间件 (UseExceptionHandler) 捕获以下中间件中引发的异常。 HTTP 严格传输安全协议

(HSTS) 中间件 (UseHsts) 添加 Strict-Transport-Security 标头。

HTTPS 重定向中间件 (UseHttpsRedirection) 将 HTTP 请求重定向到 HTTPS。

静态⽂件中间件 (UseStaticFiles) 返回静态⽂件，并简化进⼀步请求处理。

Cookie 策略中间件 (UseCookiePolicy) 使应⽤符合欧盟⼀般数据保护条例 (GDPR) 规定。

⽤于路由请求的路由中间件 (UseRouting)。

身份验证中间件 (UseAuthentication) 尝试对⽤户进⾏身份验证，然后才会允许⽤户访问安全资源。

⽤于授权⽤户访问安全资源的授权中间件 (UseAuthorization)。

会话中间件 (UseSession) 建⽴和维护会话状态。 如果应⽤使⽤会话状态，请在 Cookie 策略中间件之后

和 MVC 中间件之前调⽤会话中间件。

⽤于将 Razor Pages 终结点添加到请求管道的终结点路由中间件（带有 MapRazorPages 的

UseEndpoints）。

18.中间件的执⾏顺序？

异常/错误处理

HTTP 严格传输安全协议

64HTTPS 重定向

静态⽂件服务器

Cookie 策略实施

身份验证

会话

MVC

19.application builder 的 use 和 run ⽅法有什么区别？

这两个⽅法都在 start up class 的 configure ⽅法⾥⾯调⽤。都是⽤来向应⽤请求管道⾥⾯添加中间件的。

Use ⽅法可以调⽤下⼀个中间件的添加，⽽ run 不会。

20.dot net core 管道⾥⾯的 map 拓展有什么作⽤?

可以针对不同的路径添加不同的中间件。

1 public void Configure(IApplicationBuilder app)

2 {

3 app.Map("/path1", Middleware1);

4 app.Map("/path2", Middleware2);

5 }

21.dot net core ⾥⾯的路径是如何处理的？

路径处理是⽤来为进⼊的请求寻找处理函数的机制。所有的路径在函数运⾏开始时进⾏注册。

主要有两种路径处理⽅式， 常规路径处理和属性路径处理。常规路径处理就是⽤ MapRoute 的⽅式设定调

⽤路径，属性路径处理是指在调⽤函数的上⽅设定⼀个路径属性。

22.dot net core ⼯程⾥⾯有哪些常⻅的⼯程⽂件？

65global, launch setting，app settings，bundle config，bower, package。

23.依赖注⼊实现原理？

实现 DI，核⼼在于依赖注⼊容器 IContainer，该容器具有以下功能

①.（容器）保存可⽤服务的集合 // 要⽤的特定对象、特定类、接⼝服务

②.（注册）提供⼀种⽅式将各种部件与他们依赖的服务绑定到⼀起；// Add...函数或

containerBuilder.Register 函数，

③.（解析点）为应⽤程序提供⼀种⽅式来请求已配置的对象： 构造函数注⼊、属性注⼊.

运⾏时，框架会⼀层层通过反射构造实例，最终得到完整对象。

24.ASP.NET Core 项⽬如何设置 IP 地址和端⼝号？

可以使⽤ Properties ⽂件夹下的 launchSettings 配置⽂件来配置不同的启动⽅式的时候，分别配置 IP 和端

⼝号。

66.NET/C#⾯试题汇总系列：ADO.NET、XML、

HTTP、AJAX、WebService

1. .NET 和 C#有什么区别?

.NET ⼀般指 .NET FrameWork 框架，它是⼀种平台，⼀种技术。

C#是⼀种编程语⾔，可以基于.NET 平台的应⽤。

2.请编程遍历⻚⾯上所有 TextBox 控件并给它赋值为 string.Empty？

1 foreach (System.Windows.Forms.Control control in this.Controls)

2 {

3 if (control is System.Windows.Forms.TextBox)

4 {

5 System.Windows.Forms.TextBox tb = (System.Windows.Forms.TextBo

x)control ;

6 tb.Text = String.Empty ;

7 }

8 }

3.CTS、CLS、CLR 分别作何解释？

CTS：通⽤语⾔系统。CLS：通⽤语⾔规范。CLR：公共语⾔运⾏库。

4.什么是受管制的代码？

unsafe：⾮托管代码。不经过 CLR 运⾏。

5.什么是强类型系统？

RTTI：类型识别系统。

676.列举 ASP.NET ⻚⾯之间传递值的⼏种⽅式。

1).使⽤ QueryString, 如....?id=1; response. Redirect()....

2).使⽤ Session 变量

3).使⽤ Server.Transfer

7. 什么是 Code-Behind 技术？

代码后植。

8.在.net 中，配件的意思是？

程序集。（中间语⾔，源数据，资源，装配清单）

9. .netRemoting 的⼯作原理是什么？

服务器端向客户端发送⼀个进程编号，⼀个程序域编号，以确定对象的位置

10.分析以下代码，i=? j=?

1 stringstrTmp = "abcdefg 某某某";

2 inti= System.Text.Encoding.Default.GetBytes(strTmp).Length;

3 intj= strTmp.Length;

答：i=13,j=10

11.是否可以继承 String 类?

String 类是 final 类故不可以继承。

12.Session 有什么重⼤ BUG，微软提出了什么⽅法加以解决？

68 是 iis 中由于有进程回收机制，系统繁忙的话 Session 会丢失，可以⽤ Sate server 或 SQL Server 数据库的

⽅式存储 Session 不过这种⽅式⽐较慢，⽽且⽆法

捕获 Session 的 END 事件。

13.DataReader 与 Dataset 有什么区别？

⼀个是只能向前的只读游标，⼀个是内存中虚拟的数据库。

14.什么是 XML？

XML 即可扩展标记语⾔。eXtensible Markup Language.标记是指计算机所能 理解的信息符号，通过此

种标记，计算机之间可以处理包含各种信息的⽂章等。如何定义这些标记，即可以选择国际通⽤的标记语

⾔，⽐如 HTML，也可以使⽤象 XML 这样由相关⼈⼠⾃由决定的标记语⾔，这就是语⾔的可扩展性。XML

是从 SGML 中简化修改出来的。它主要⽤到的有 XML、XSL 和 XPath 等。

15.什么是 WebService？UDDI？

Web Service 便是基于⽹络的、分布式的模块化组件，它执⾏特定的任务，遵守具体的技术规范，这些规

范使得 Web Service 能与其他兼容的组件进⾏互操作。UDDI 的⽬的是为电⼦商务建⽴标准；UDDI 是⼀套

基于 Web 的、分布式的、为 WebService 提供的、信息注册中⼼的实现标准规范，同时也包含⼀组使企业能

将⾃身提供的 Web Service 注册，以使别的企业能够发现的访问协议的实现标准。

16.什么是 ASP.net 中的⽤户控件？

⽤户控件⼀般⽤在内容多为静态,或者少许会改变的情况下..⽤的⽐较⼤..类似 ASP 中的 include..但是功能要

强⼤的多。

17.列举⼀下你所了解的 XML 技术及其应⽤

xml ⽤于配置,⽤于保存静态数据类型.接触 XML 最多的是 web Services..和 config

18. 什么是 code-Behind 技术？

ASPX,RESX 和 CS 三个后缀的⽂件，这个就是代码分离.实现了 HTML 代码和服务器代码分离.⽅便代码编写

和整理。

6919.什么是 SOAP,有哪些应⽤？

simple object access protocal,简单对象接受协议.以 xml 为基本编码结构,建⽴在已有通信协议上(如

http,不过据说 ms 在搞最底层的架构在 tcp/ip 上的 soap)的⼀种规范 WebService 使⽤的协议。

20.C#中 property 与 attribute 的区别，他们各有什么⽤处，这种机制的好处在哪⾥？

⼀个是属性，⽤于存取类的字段，⼀个是特性，⽤来标识类，⽅法等的附加性质。

21.XML 与 HTML 的主要区别？

1. XML 是区分⼤⼩写字⺟的，HTML 不区分。

2.在 HTML 中，如果上下⽂清楚地显示出段落或者列表键在何处结尾，那么你可以

省略

3.在 XML 中，拥有单个标记⽽没有匹配的结束标记的元素必须⽤⼀个 / 字符作为

结尾。这样分析器就知道不⽤查找结束标记了。

4.在 XML 中，属性值必须分装在引号中。在 HTML 中，引号是可⽤可不⽤的。

5.在 HTML 中，可以拥有不带值的属性名。在 XML 中，所有的属性都必须带有相应的值。

21.在.Net 中，类 System.Web.UI.Page 可以被继承么？

可以。

22.在.net（C# or vb.net）中，Appplication.Exit 还是 Form.Close 有什么不同？

⼀个是退出整个应⽤程序，⼀个是关闭其中⼀个 form。

23.<%# %> 和 <% %> 有什么区别？

70<%# %>表示绑定的数据源

<%%>是服务器端代码块

24.ADO.NET 中读写数据库需要使⽤哪些对象？作⽤是什么？

Connection 连接对象，Command 执⾏命令和存储过程，DataReader 向前只读的数据流，DataAdapter

适配器，⽀持增删查询，DataSet 数据级对象，相当与内存⾥的⼀张或多张表。

25.什么是 SQL 注⼊，应该如何防⽌?

利⽤ sql 关键字对⽹站进⾏攻击,⽤参数化的 SQL 就可以避免 SQL 注⼊!

26.详细描述三层架构开发模式以及三层架构的好处?

数据访问层，业务层，表示层。

数据访问层（DAL），主要是存放对数据类的访问，即对数据库的添加、删除、修改、更新等基本操作

业务逻辑层（BLL）对传送数据进⾏逻辑判断分折，并进⾏传送正确的值。

表示层为了与⽤户交互例如⽤户添加表单。

优点： 分⼯明确，条理清晰，易于调试，⽽且具有可扩展性。

27.说出⼀些常⽤的类、接⼝，请各举 5 个?

要让⼈家感觉你对.Net 开发很熟，所以，不能仅仅只列谁都能想到的那些东⻄，要多列你在做项⽬中涉及

的那些东⻄。就写你最近写的那些程序中涉及的那些类。

常⽤的类：StreamReader、WebClient、Dictionary<K,V>、StringBuilder、SqlConnection、

FileStream、File、Regex、List

常⽤的接⼝：IDisposable、IEnumerable、IDbConnection、IComparable、ICollection、IList、

IDictionary

28.不是说字符串是不可变的吗？string s="abc";s="123"不就是变了吗？

7172

String 是不可变的在这段代码中，s 原先指向⼀个 String 对象，内容是 "abc"，然后我们将 s 指向"123"，那

么 s 所指向的那个对象是否发⽣了改变呢？答案是没有。这时，s 不指向原来那个对象了，⽽指向了另⼀个

String 对象，内容为"123"，原来那个对象还存在于内存之中，只是 s 这个引⽤变量不再指向它了。

get 的参数会显示在浏览器地址栏中，⽽ post 的参数不会显示在浏览器地址栏中；

使⽤ post 提交的⻚⾯在点击【刷新】按钮的时候浏览器⼀般会提示“是否重新提交”，⽽ get 则不会；

⽤ get 的⻚⾯可以被搜索引擎抓取，⽽⽤ post 的则不可以；

⽤ post 可以提交的数据量⾮常⼤，⽽⽤ get 可以提交的数据量则⾮常⼩(2k)，受限于⽹⻚地址的⻓度。

⽤ post 可以进⾏⽂件的提交，⽽⽤ get 则不可以。

301：永久重定向；302：暂时重定向。

它们的区别是，301 对搜索引擎优化（

SEO）更加有利；302 有被提示为⽹络拦截的⻛险。

Server.Transfer 仅是服务器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；

Response.Redirect 则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览

器的地址栏中可以看到跳转后的链接地址。

Server.Transfer 是服务器请求资源，服务器直接访问⽬标地址的 URL，把那个 URL 的响应内容读取过来，

然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪⼉来的，所以它的地址栏中还

是原来的地址。 这个过程中浏览器和 Web 服务器之间经过了⼀次交互。

Response.Redirect 就是服务端根据逻辑,发送⼀个状态码,告诉浏览器重新去请求那个地址，⼀般来说浏览

器会⽤刚才请求的所有参数重新请求。这个过程中浏览器和 Web 服务器之间经过了两次交互。

Server.Transfer 不可以转向外部⽹站，⽽ Response.Redirect 可以。

29.post、get 的区别?

30.http 响应码 301 和 302 代表的是什么？有什么区别？

31.Server.Transfer 和 Response.Redirect 的区别是什么？73

Server.Execute 效果和 Server.Transfer 类似，但是是把执⾏的结果嵌⼊当前⻚⾯。

XSS 攻击：即跨站脚本攻击，它是 Web 程序中常⻅的漏洞。原理是攻击者往 Web ⻚⾯⾥插⼊恶意的脚

本代码（

css 代码、Javascript 代码等），当⽤户浏览该⻚⾯时，嵌⼊其中的脚本代码会被执⾏，从⽽达

到恶意攻击⽤户的⽬的，如盗取⽤户 cookie、破坏⻚⾯结构、重定向到其他⽹站等。 预防 XSS 的核⼼是

必须对输⼊的数据做过滤处理。

fetch 发送 post 请求的时候，总是发送 2 次，第⼀次状态码是 204，第⼆次才成功？

原因很简单，因为你⽤ fetch 的 post 请求的时候，导致 fetch 第⼀次发送了⼀个 Options 请求，询问服务器

是否⽀持修改的请求头，如果服务器⽀持，则在第⼆次中发送真正的请求。

可以将 http ⾸部分为通⽤⾸部，请求⾸部，响应⾸部，实体⾸部

通⽤⾸部表示⼀些通⽤信息，⽐如 date 表示报⽂创建时间，

请求⾸部就是请求报⽂中独有的，如 cookie，和缓存相关的如 if-Modified-Since

响应⾸部就是响应报⽂中独有的，如 set-cookie，和重定向相关的 location，

实体⾸部⽤来描述实体部分，如 allow ⽤来描述可执⾏的请求⽅法，content-type 描述主题类型，

content-Encoding 描述主体的编码⽅式

CSRF：Cross-Site Request Forgery（中⽂：跨站请求伪造），可以理解为攻击者盗⽤了你的身份，以

你的名义发送恶意请求，⽐如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。 防御⼿段：

验证请求来源地址； 关键操作添加验证码； 在请求地址添加 token 并验证。

32.什么是 XSS 攻击，如何避免？

33.HTTP fetch 发送 2 次请求的原因？

34.HTTP 常⻅的的头部有哪些？

35.什么是 CSRF 攻击，如何避免？

36.HTTP 状态码 304 的含义？什么时候⽤ 304？304：如果客户端发送了⼀个带条件的 GET 请求且该请求已被允许，⽽⽂档的内容（⾃上次访问以来或者

根据请求的条件）并没有改变，则服务器应当返回这个 304 状态码。

37.ASP.NET 和 ASP 有什么区别?

ASP.NET 的脚本是⾬ HTML 分离的，代码被编译成了 DLL, DLL 可以在 server 端执⾏。

ASP 的脚本是与 HTML 在⼀起的，每次都会进⾏解释执⾏。

38.简述 Application，session，cookie，cache，viewState 的概念，以及相互之间的区

别?

Application 任意⼤⼩ 整个应⽤程序的⽣命期 所有⽤户 服务器端

Seccion ⼩量，简单的数据 ⽤户活动时间+ 单个⽤户 服务器端⼀段延迟时间（⼀般为 20 分钟）

Cookie ⼩量，简单的数据 可以根据需要设定 单个⽤户 客户端

ViewState ⼩量，简单的数据 ⼀个 Web ⻚⾯的⽣命期 单个⽤户 客户端

Cache 任意⼤⼩ 可以根据需要设定 所有⽤户 服务器端

39.ASP.NET 中的六⼤对象有哪些？

1.Response

2.Request

3.Server

4.Application

5.Session

6.Cookie

40. 在 c#中，反射是什么？处理反射相关的 namespace 是什么？

反射（Reflection）是.NET 中的重要机制，通过放射，可以在运⾏时获 得.NET 中每⼀个类型（包括类、

结构、委托、接⼝和枚举等）的成员，包括⽅法、属性、事件，以及构造函数等。还可以获得每个成员的

名称、限定符和参数等。

7441.ExecuteScalar 和 ExecuteNonQuery 的区别?

ExecuteNonQuery：返回受影响的⾏数。

ExecuteScalar：返回结果集的第⼀⾏第⼀列，忽略其他⾏。

42.说明 C#中的⽅法声明参数关键字 params，ref，out 的意义及⽤法?

1） params 关键字，官⽅给出的解释为⽤于⽅法参数⻓度不定的情况。有时候不能确定⼀个⽅法的⽅法参

数到底有多少个，可以使⽤ params 关键字来解决问题

2） ref 关键字：使⽤引⽤类型参数，在⽅法中对参数所做的任何更改都将反应在该变量中

3. out 关键字：out 与 ref 相似但是 out ⽆需进⾏初始化。

   43.简单描述 Ihtttphandler 和 Ihttpmodule 的区别和各⾃的作⽤？

1.先后次序.先 IHttpModule,后 IHttpHandler. 注:Module 要看你响应了哪个事件，⼀些事件是在 Handler 之

前运⾏的，⼀些是在 Handler 之后运⾏的

2.对请求的处理上:

IHttpModule 是属于⼤⼩通吃类型,⽆论客户端请求的是什么⽂件,都会调⽤到它;例如 aspx,rar,html 的请

求.

IHttpHandler 则属于挑⻝类型,只有 ASP.net 注册过的⽂件类型(例如 aspx,asmx 等等) 才会轮到调⽤它.

3.IHttpHandler 按照你的请求 ⽣成响应的内容，IHttpModule 对请求进⾏预处理，如验证、修改、过滤等

等，同时也可以对响应进⾏处理

44. 什么是托管代码、⾮托管代码托管代码 (managed code)

由公共语⾔运⾏库环境（⽽不是直接由操作系统）执⾏的代码。托管代码应⽤程序可以获得公共语⾔运⾏

库服务，例如⾃动垃圾回收、运⾏库类型检查和安全⽀持等。这些服务帮助提供独⽴于平台和语⾔的、统

⼀的托管代码应⽤程序⾏为。

⾮托管代码 (unmanaged code)

在公共语⾔运⾏库环境的外部，由操作系统直接执⾏的代码。⾮托管代码必须提供⾃⼰的垃圾回收、类型

检查、安全⽀持等服务；它与托管代码不同，后者从公共语⾔运⾏库中获得这些服务。

7545.GC 是什么? 为什么要有 GC?

1.GC 是垃圾收集器。程序员不⽤担⼼内存管理，因为垃圾收集器会⾃动进⾏管理.

2 .NET 的 GC 机制有这样两个问题：⾸先，GC 并不是能释放所有的资源。它不能⾃动释放⾮托管资源。

GC 并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。

GC 就是对“不可达“的对象进⾏回收，释放内存。

46.数组、链表、哈希、队列、栈数据结构特点，各⾃优点和缺点？

数组(Array)：

优点：查询快，通过索引直接查找；有序添加，添加速度快，允许重复；

缺点：在中间部位添加、删除⽐较复杂，⼤⼩固定，只能存储⼀种类型的数据；

如果应⽤需要快速访问数据，很少插⼊和删除元素，就应该⽤数组。

链表(LinkedList)：

优点：有序添加、增删改速度快，对于链表数据结构，增加和删除只要修改元素中的指针就可以了；

缺点：查询慢，如果要访问链表中⼀个元素，就需要从第⼀个元素开始查找；

如果应⽤需要经常插⼊和删除元素，就应该⽤链表。

栈(Stack)：

优点：提供后进先出的存储⽅式，添加速度快，允许重复；

缺点：只能在⼀头操作数据，存取其他项很慢；

队列(Queue)：

优点：提供先进先出的存储⽅式，添加速度快，允许重复；

缺点：只能在⼀头添加，另⼀头获取，存取其他项很慢；

哈希(Hash)：

特点：散列表，不允许重复；

优点：如果关键字已知则存取速度极快；

缺点：如果不知道关键字则存取很慢，对存储空间使⽤不充分；

47.应⽤程序池集成模式和经典模式的区别?

如果托管应⽤程序在采⽤集成模式的应⽤程序池中知运⾏，服务器将使⽤ IIS 和 ASP.NET 的集成请求处

理管道来处理请求。

76 如果托管应⽤程序在采⽤经典模式的应⽤程序池中运⾏，服务器会继续通过 Aspnet_isapi.dll

路由托管代码请求，其处理请求的⽅式就像应⽤程序在 IIS 6.0 中运⾏⼀样。

48.AJAX 的底层实现原理?

Ajax 核⼼—-----XMLHttpRequest

上⾯我们⼤概感受了⼀下 Ajax 的过程，我们发现发送异步请求才是核⼼，事实上它就是

XMLHttpRequest，整个 Ajax 之所以能完成异步请求完全是因为这个对应可以发送异步请求的缘故。

⽽且我们⼜发现上⾯那个事件就是整个处理过程的核⼼，可以根据不同状态执⾏不同操作，其实它就是

XMLHttpRequest 的⽅法 onreadystatechange，它在每次状态发⽣改变时都会触发。那么是谁取得的返

回信息呢？它就是 XMLHttpRequest 的另⼀个⽅法 responseText（当然还有 responseXML）。

我们还没有说发送给谁以及执⾏发送操作，这两个就是 XMLHttpRequest 的 open 和 send ⽅法。Y(o)Y，其

他的当然还有了，我们直接列出来吧：

XMLHttpRequest 对象属性

readyState：请求状态，开始请求时值为 0 直到请求完成这个值增⻓到 4

responseText：⽬前为⽌接收到的响应体,readyState<3 此属性为空字符串，=3 为当前响应体，=4 则为

完整响应体

responseXML：服务器端相应，解析为 xml 并作为 Document 对象返回

status：服务器端返回的状态码，=200 成功，=404 表示“Not Found”

statusText：⽤名称表示的服务器端返回状态，对于“OK”为 200，“Not Found”为 400

⽅法

setRequestHeader()：向⼀个打开但是未发⽣的请求设置头信息

open()：初始化请求参数但是不发送

send()：发送 Http 请求

abort()：取消当前相应

77getAllResponseHeaders()：把 http 相应头作为未解析的字符串返回

getResponseHeader()：返回 http 相应头的值

49.能够将⾮静态的⽅法覆写成静态⽅法吗？

答：不能，覆写⽅法的签名必须与被覆写⽅法的签名保持⼀致，除了将 virtual 改为 override。

50.DateTime.Parse(myString); 这⾏代码有什么问题？

有问题，当 myString 不能满⾜时间格式要求的时候，会引发异常，建议使⽤ DateTime.TryParse()

51.Server.UrlEncode、HttpUtility.UrlDecode 的区别

Server.UrlEncode 的编码⽅式是按照本地程序设置的编码⽅式进⾏编码的，⽽ HttpUtility.UrlEncode 是默

认的按照.net 的 utf-8 格式进⾏编码的。

52.何时创建连接池？

当第⼀个连接请求到来时创建连接池；连接池的建⽴由数据库连接的连接字符创来决定。每⼀个连接池都

与⼀个不同的连接字符串相关。当⼀个新的连接请求到来时如果连接字符串和连接池使⽤的字符串相同，

就从连接池取出⼀个连接；如果不相同，就新建⼀个连接池。

53.何时关闭连接池？

当连接池中的所有连接都已经关闭时关闭连接池。

54. 当连接池中的连接都已经⽤完，⽽有新的连接请求到来时会发⽣什么？

当连接池已经达到它的最⼤连接数⽬时，有新的连接请求到来时，新的连接请求将放置到连接队列中。当

有连接释放给连接池时，连接池将新释放的连接分配给在队列中排队的连接请求。你可以调⽤ close 和

dispose 将连接归还给连接池。

55.如何允许连接池？

78 对于.NET 应⽤程序⽽⾔，默认为允许连接池。（这意味着你可以不必为这件事情做任何的事情）当然，如

果你可以在 SQLConnection 对象的连接字符串中加进 Pooling=true;确保你的应⽤程序允许连接池的使

⽤。

56.应该如何禁⽌连接池？

ADO.NET 默认为允许数据库连接池，如果你希望禁⽌连接池，可以使⽤如下的⽅式：

1. 使⽤ SQLConnection 对象时，往连接字符串加⼊如下内容：Pooling=False;
2. 使⽤ OLEDBConnection 对象时，往连接字符串加⼊如下内容：OLE DB Services=-4;
3. 私有程序集与共享程序集有什么区别？

⼀个私有程序集通常为单个应⽤程序所使⽤，并且存储于这个应⽤程序所在的⽬录之中，或此⽬录下⾯的

⼀个⼦

⽬录中。共享程序集通常存储在全局程序集缓存（Global Assembly Cache）之中，这是⼀个由.NET 运⾏

时所维

护的程序集仓库。共享程序集通常是对许多应⽤程序都有⽤的代码库，⽐如.NET Framework 类。

58.请解释 web.config ⽂件中的重要节点？

appSettings 包含⾃定义应⽤程序设置。

system.web 系统配置；

compilation 动态调试编译设置；

customErrors ⾃定义错误信息设置；

authentication 身份验证,此节设置应⽤程序的身份验证策略。

authorization 授权, 此节设置应⽤程序的授权策略。

59.什么是 viewstate，能否禁⽤？是否所⽤控件都可以禁⽤?

Viewstate 是保存状态的⼀种机制，EnableViewState 属性设置为 false 即可禁⽤

60.什么是 Windows 服务，它的⽣命周期与标准的 EXE 程序有什么不同？

7980

Windows 服务是运⾏在 windows 后台指定⽤户下（默认 System）的应⽤程序，它没有标准的 UI 界⾯，想

⽐标准

的 EXE 程序，Windows 服务是在服务开始的时候创建，⽽在服务结束的时候销毁，⽽且可以设置服务是否

与操作

系统⼀起启动，⼀起关闭。它⽀持三种⽅式：１）⾃动⽅式 2）⼿动⽅式 ３）禁⽤ 。⾃动⽅式的时

候，windows 服务将在 OS 启动后⾃动启动运⾏，⽽⼿动⽅式则必须⼿⼯启动服务，禁⽤的情况下服务将不

能被

启动。另外标准的 EXE 默认使⽤的当前登录的⽤户，⽽ windows 服务则默认使⽤ System ⽤户，这在对系统

资源访

问的时候特别需要注意。

Gloal Assembly Cache，全局应⽤程序集缓存。它解决了⼏个程序共享某⼀个程序集的问题。不必再将

那个被共

享的程序集拷⻉到应⽤程序⽬录了，其实这道理很简单，.net 应⽤程序在加载的时候，会⾸先查看全局应

⽤程序

集缓存，如果有就可以直接使⽤，没有再到应⽤程序⽬录进⾏查找。

（

1）浏览器使⽤缓存；（

2）使⽤压缩的 JS 和 CSS（

3）减少发送 HTTP 请求的次数；（

4）后台，对于⼀

些不经常变化的数据进⾏ Cache；（

5）对可能的低效率的 SQL 语句进⾏优化；（

6）进⾏服务器负载均衡

61.什么是 GAC？它解决了什么问题?

62.数据访问通过 aspx ⻚⾯和 DB 层会很慢，有什么解决⽅法?.NET/C#⾯试题汇总系列：常⻅的算法

1.求质数

质数也成为素数，质数就是这个数除了 1 和他本身两个因数以外，没有其他因数的数，叫做质数，和他相反

的是合数，

就是除了 1 和他本身两个因数以外，还友其他因数的数叫做合数。

1 //以下为函数部分

2 static void cal(long x)

3 {

4 long sum = 1;

5 byte row = 1;

6 Console.Write("\n");

7 for (long a = 3; a < x + 1; a++)

8 {

9 bool flag = true;

10 for (long b = 2; b < (a / 2) + 1; b++)

11 {

12 if (a % b != 0) continue;

13 flag = false;

14 break;

15 }

16 if (flag)

17 {

18 if (row == 10) { Console.WriteLine(); row = 0;

}

19 if (sum == 1) Console.Write("{0,7}", 2);

20 Console.Write("{0,7}", a);

21 sum++; row++;

22 }

23 }

24 Console.WriteLine("\n\n{0} 以内共有 {1} 个质数\n", x, s

um);

25 }

812.有⼀列数 1，1，2，3，5，........求第 30 个数.

1 public static int Foo(int i)

2 {

3 if (i <= 0)

4 return 0;

5 else if (i > 0 && i <= 2)

6 return 1;

7 else

8 return Foo(i - 1) + Foo(i - 2);

9 }

3.冒泡排序

1 //冒泡排序类

2 public class sorter

3 {

4 public void Sort(int[] list)

5 {

6 int i, j, temp;

7 bool done = false;

8 j = 1;

9 while ((j < list.Length) && (!done))

10 {

11 done = true;

12 for (i = 0; i < list.Length - j; i++)

13 {

14 if (list[i] > list[i + 1])

15 {

16 done = false;

17 temp = list[i];

18 list[i] = list[i + 1];

19 list[i + 1] = temp;

20 }

21 }

8283

例如输⼊参数为整型数组{9，7，2}，那么输出结果为字符串"9,7,2"。

22 j++;

23 }

24 }

25 }

4.请编写⼀个函数，能够计算 10 以内数的阶乘，尽量采⽤递归算法。（

10!=3628800）。

1 public int jiecheng(int n)

2 {

3 if (n == 1)

4 return 1;

5 else if (n == 2)

6 return 2;

7 else

8 return n \* jiecheng(n - 1);

9 }

5 请编程实现此⽅法。将输⼊的整型数组，合并转换为逗号分隔的字符串。

1 private static string Combine(int[] data)

2 {

3 string str = "";

4 foreach (int s in data)

5 {

6 str += s.ToString() + ",";

7 }

8 return str;

9 }

6.产⽣⼀个 int 数组，⻓度为 100，并向其中随机插⼊ 1-100，并且不能重复。

1 //产⽣⼀个 int 数组，⻓度为 100，并向其中随机插⼊ 1-100，并且不能重复。2 int[] arr = new int[100];

3 ArrayList myList = new ArrayList();

4 Random rad = new Random();

5 while (myList.Count < 100)

6 {

7 int num = rad.Next(1, 101);

8 if (!myList.Contains(num))

9 {

10 myList.Add(num);

11 }

12 }

13 for (int i = 0; i < 100; i++)

14 {

15 arr[i] = (int)myList[i];

16 }

17 for (int i = 0; i < arr.Length; i++)

18 {

19 Console.Write(arr[i] + ",");

20 }

21 Console.ReadKey();

7.请将字符串"I am a student"按单词逆序输出 如"student a am I"

1 string S = "I am a student";

2 char[] C = new char[] { ' '};

3 string[] n =S.Split(C);

4 int length = S.Length;

5 for (int i =length-1 ; i >=0; i--)

6 {

7 Console.Write(n[i]);

8 if (i != 0)

9 {

10 Console.Write(" ");

11 }

12 }

8.C# 取两个数组的相同元素

84 摘要: 以往我们都是肯定绞尽脑汁，肯定什么循环，元素⼤⼩，什么因素都考虑进去。但是现在采⽤ Linq 可

以很好的解决这个问题。找出两个或多个数组的相同项。代码如下：

1 usingSystem;

2 usingSystem.Collections.Generic;

3 usingSystem.Linq;

4 usingSystem.Text;

5 namespaceTest4_03

6 {

7 classProgram

8 {

9 staticvoidMain(string[] args)

10 {

11 string[] names = {"Adams","Arthur","Buchanan","Tsbuch

is","ShCian","FuchsiaLinda","DecheChen","Lotheer","FindLanciCad

e",

12 "SorchLand","JiangZheng","MisiiLoda","Gtod","Dfac","L

ama","BakCades","Losangle","ZheWQ","GehengDahaLothi","ToryLande

y",

13 "DakaLothy","BthLanda","MenNorth","Fith","FoxMain","D

ontM","Saobba","Del","Sala","Ghero","BhthLaPhda"};

14 IEnumerable<string> skip = names.Skip(10);

15 IEnumerable<string> take = names.Take(11);

16 //取出两个序列中交集部分，按理论应该输出 JiangZheng

17 IEnumerable<string> intersect = skip.Intersect(take);

18 foreach(varsinintersect)

19 {

20 Console.WriteLine(s);

21 }

22 Console.ReadKey();

23 }

24 }

25 }

9.有⼀个字符串 "I am a good man",设计⼀个函数,返回 "man good a am I"。

851 static string Reverse()

2 {

3 string s = "I am a good man";

4 string[] arr = s.Split(' ');

5 string res = "";

6 for (int i = arr.Length - 1; i >= 0; i--)

7 {

8 res += arr[i];

9 if (i > 0)

10 res += " ";

11 }

12 return res;

13 }

10.有 1、2、3、4 个数字，能组成多少个互不相同且⽆重复数字的三位数？都是多少？

1 class Program

2 {

3 static void Main(string[] args)

4 {

5

6 //有 1、2、3、4 个数字，能组成多少个互不相同且⽆重复数字的三位数？

都是多少？

7 //分解题⽬

8 //条件：四个数字 1、2、3、4 ；三位数：百位、⼗位、个位

9 //要求：互不相同；⽆重复数字：每个数字在三位中只出现⼀次

10 //结果：多少个？ 都是多少？

11

12 int count = 0; //统计个数

13 for (int bw = 1; bw <= 4; bw++)

14 {

15 for (int sw = 1; sw <= 4; sw++)

16 {

17 if (sw!= bw) //很显然，只有百位和⼗位不同的情况下才

能谈个位。

18 {

19 for (int gw = 1; gw <= 4; gw++)

20 {

8621 if (gw != sw && gw != bw) //百位⽤过

的，⼗位就不能⽤；百位和⼗位都⽤过的，个位就不能⽤

22 {

23 count++;

24 Console.WriteLine("{0}{1}{2}", bw,

sw, gw);

25 }

26 }

27 }

28 }

29 }

30 Console.WriteLine("⼀共有{0}个", count);

31 Console.Read();

32

33 }

34 }

11.产⽣⼀个 int 数组，⻓度为 100，并向其中随机插⼊ 1-100，并且不能重复。

1 int[] intArr=new int[100];

2 ArrayList myList=new ArrayList();

3 Random rnd=new Random();

4 while(myList.Count<100)

5 {

6 int num=rnd.Next(1,101);

7 if(!myList.Contains(num))

8 myList.Add(num);

9 }

10 for(int i=0;i<100;i++)

11 intArr[i]=(int)myList[i];

12.⽤ C#写⼀段选择排序算法，要求⽤⾃⼰的编程⻛格。

1 public void xuanZhe(int[] list)//选择排序

2 {

3 for (int i = 0; i < list.Length – 1; i++)

874 {

5 min = i;

6 for (int j = i + 1; j < list.Length; j++)

7 {

8 if (list[j] < list[min])

9 min = j;

10 }

11 int t = list[min];

12 list[min] = list[i];

13 list[i] = t;

14 }

15 }

13.有⼀个 10 个数的数组，计算其中不重复数字的个数。{3,5,9,8,10,5,3},⽤ HashSet。

1 int[] values = { 3, 5, 9, 8, 10, 5, 3 };

2 HashSet<int> set = new HashSet<int>();

3 foreach (int i in values)

4 {

5 set.Add(i);

6 }

7 foreach (int i in set)

8 {

9 Console.WriteLine(i);

10 }

14. Ａ、Ｂ、Ｃ、Ｄ、Ｅ五名学⽣有可能参加计算机竞赛，根据下列条件判断哪些⼈参加了竞

赛：

（１）Ａ参加时，Ｂ也参加；

（２）Ｂ和Ｃ只有⼀个⼈参加；

（３）Ｃ和Ｄ或者都参加，或者都不参加；

（４）Ｄ和Ｅ中⾄少有⼀个⼈参加；

88（５）如果Ｅ参加，那么Ａ和Ｄ也都参加。

1 static void Main(string[] args)

2 {

3 char[] name={'A','B','C','D','E'};

4 int[] value = new int[5];

5 for (value[0]=0;value[0]<2;value [0]++)

6 for (value[1]=0; value[1] < 2; value[1]++)

7 for (value[2]=0; value[2] < 2; value[2]++)

8 for (value[3]=0; value[3] < 2; value[3]++)

9 for (value[4]=0; value[4] < 2; value[4]++)

10 {

11 if ((value[1] >= value[0]) && (value[1] + value[2] == 1) && (va

lue[2] == value[3]) && (value[3] + value[4]==1) && (value[4]==0 |

| value[4]==1 && value[0]==1 && value[3]==1))

12 {

13 for (int i = 0; i < 5; i++)

14 {

15 if (value[i]==1)

16 {

17 Console.WriteLine("{0}参加", name[i]);

18 }

19 else

20 {

21 Console.WriteLine("{0}不参加", name[i]);

22 }

23 }

24 }

25 }

26 }

15.程序设计: 猫⼤叫⼀声，所有的⽼⿏都开始逃跑，主⼈被惊醒。

1 public delegate void SubEventHandler();

2 public abstract class Subject

3 {

894 public event SubEventHandler SubEvent;

5 protected void FireAway()

6 {

7 if (this.SubEvent != null)

8 this.SubEvent();

9 }

10 }

11 public class Cat : Subject

12 {

13 public void Cry()

14 {

15 Console.WriteLine(cat cryed.);

16 this.FireAway();

17 }

18 }

19 public abstract class Observer

20 {

21 public Observer(Subject sub)

22 {

23 sub.SubEvent += new SubEventHandler(Response);

24 }

25 public abstract void Response();

26 }

27 public class Mouse : Observer

28 {

29 private string name;

30 public Mouse(string name, Subject sub) : base(sub)

31 {

32 this.name = name;

33 }

34 public override void Response()

35 {

36 Console.WriteLine(name + attempt to escape!);

37 }

38 }

39 public class Master : Observer

40 {

41 public Master(Subject sub) : base(sub){}

42 public override void Response()

43 {

9044 Console.WriteLine(host waken);

45 }

46 }

47 class Class1

48 {

49 static void Main(string[] args)

50 {

51 Cat cat = new Cat();

52 Mouse mouse1 = new Mouse(mouse1, cat);

53 Mouse mouse2 = new Mouse(mouse2, cat);

54 Master master = new Master(cat);

55 cat.Cry();

56 }

57 }

16.写⼀个冒泡排序

1 public class bubblesorter

2 {

3 public void sort(int[] list)

4 {

5 int i, j, temp;

6 bool done = false;

7 j = 1;

8 while ((j < list.Length) && (!done))

9 {

10 done = true;

11 for (i = 0; i < list.Length - j; i++)

12 {

13 if (list[i] > list[i + 1])

14 {

15 done = false;

16 temp = list[i];

17 list[i] = list[i + 1];

18 list[i + 1] = temp;

19 }

20 }

21 j++;

9122 }

23 }

24 }

17. 写⼀个选择排序

1 public class selectionsorter

2 {

3 private int min;

4 public void sort(int[] list)

5 {

6 for (int i = 0; i < list.Length - 1; i++)

7 {

8 min = i;

9 for (int j = i + 1; j < list.Length; j++)

10 {

11 if (list[j] < list[min])

12 min = j;

13 }

14 int t = list[min];

15 list[min] = list[i];

16 list[i] = t;

17 }

18 }

19 }

18.⼀列数的规则如下: 1、1、2、3、5、8、13、21、34...... 求第 30 位数是多少，⽤递归算

法实现。

1 public class MainClass

2 {

3 public static void Main()

4 {

5 Console.WriteLine(Foo(30));

6 }

7 public static int Foo(int i)

928 {

9 if (i <= 0)

10 return 0;

11 else if(i > 0 && i <= 2)

12 return 1;

13 else return Foo(i -1) + Foo(i - 2);

14 }

15 }

9394

.NET/C#⾯试题汇总系列：数据库概念知识

其实这个不是⼀定的，有些场景下，⼩系统或者没什么⽤的表，不设置主键也没关系，mysql 最好是⽤⾃增

主键，主要是以下两个原因：如果定义了主键，那么 InnoDB 会选择主键作为聚集索引、如果没有显式定义

主键，则 innodb 会选择第⼀个不包含有 NULL 值的唯⼀索引作为主键索引、如果也没有这样的唯⼀索引，

则 innodb 会选择内置 6 字节⻓的 ROWID 作为隐含的聚集索引。所以，反正都要⽣成⼀个主键，那你还不如

⾃⼰指定⼀个主键，提⾼查询效率！

在 mysql 中，Int 整型的范围（

-2147483648~2147483648），约 20 亿！因此不⽤考虑⾃增 ID 达到最⼤值

这个问题。⽽且数据达到千万级的时候就应该考虑分库分表了。

我们在实际应⽤中，都是⽂件形式存储的。mysql 中，只存⽂件的存放路径。虽然 mysql 中 blob 类型可以⽤

来存放⼤容量⽂件，但是，我们在⽣产中，基本不⽤！主要有如下⼏个原因：

Mysql 内存临时表不⽀持 TEXT、BLOB 这样的⼤数据类型，如果查询中包含这样的数据，查询效率会⾮

常慢。

数据库特别⼤，内存占⽤⾼，维护也⽐较麻烦。

binlog 太⼤，如果是主从同步的架构，会导致主从同步效率问题！因此，不推荐使⽤ blob 等类型！

Inner join, left join, right join, full join.

Inner join, 就是只要有⼀个列能够匹配， 就简单的返回两个 table 中所有的对应⾏。

1 为什么要⼀定要设置主键?

2.⾃增主键⽤完了怎么办?

3.为什么不直接存储图⽚、⾳频、视频等⼤容量内容?

4.有⼏种不同的 join?

1 select columnnames from tablename1 inner join tablename2 on column

name1=columnname2Left join 也就是 left outer join。当有⼀个列能够匹配时就返回左边表中所有的⾏。

1 select columnnames from tablename1 left join tablename2 on columnn

ame1=columnname2

Right join 也就是 right outer join，当有列匹配时，返回右边表格中所有的⾏。

1 select columnnames from tablename1 right join tablename2 on column

name1=columnname2

Full join 也就是 full outer join, 当有匹配时， 会返回左边表格和右边表格任意情况下的⾏组合。

5.Sql 和 my sql 的区别是什么?

Sql 是结构化查询语⾔，my sql 是⼀个关系型数据库。

6.Delete 和 truncate 的区别是什么?

Delete 是 dml，truncate 是 ddl。

Delete 是⽤来删除⼀⾏或者多⾏。Truncate 是⽤来删除⼀个表中的所有⾏。

我们可以⽤ where 跟 delete 结合使⽤。Truncate 不可以。

7.Drop 跟 truncate 的区别是什么?

truncate 是删除表中所有的⾏，drop 是删除整张表。这两个操作都不可以回撤。

8.什么是关系？有⼏种关系?

关系是指多表在数据库中的关联。

有 4 种关系。

9596

1 对 1，多对⼀，多对多，⼀对多。

唯⼀标识⼀条记录，不能有重复的，不允许为空。

表的外键是另⼀表的主键, 外键可以有重复的, 可以是空值。

select \* from tablename sample 10

1433

SQL（结构化查询语⾔）是⼀种设计⽤于检索和操作数据的数据库。它属于美国国家标准协会（

ANSI）的

⼀种标准，可⽤于执⾏ Select（选择）、Update（更新）、Delete（删除）和 Insert（插⼊）等数据任

务。

它可⽤于设置表中数据类型的限制。在创建或更新表语句时，可以使⽤约束。⼀些限制是：

NOT NULL、PRIMARY KEY、FOREIGN KEY、UNIQUE、CHECK、DEFAULT

索引⽤于加速查询的性能。它可以更快地从表中检索数据。可以在⼀组列上创建索引。

9.什么是主键？

10. 什么是外键？

11.如何随机的从表中取⾏?

12.Sql server 的 TCP/ip 端⼝是什么?

13.什么是 SQL？

14.SQL 中的 Constraints(约束)是什么？

15.什么是 Index（索引）？

16.Clustered（群集）和 Non-Clustered Index（⾮群集）索引之间有什么区别？聚集索引——有助于轻松检索数据，并且只有⼀个聚集索引与⼀个表⼀起分配。它会更改记录在数据库中

的保存⽅式。

⾮聚集索引——与聚集索引相⽐，⾮聚集索引很慢。并且在⾮集群索引的情况下，该表可以具有多个索

引，为表创建⼀个对象，该表是搜索后指向表的⼀个点。

17.什么是 Aggregate Functions（聚合函数）？

它是⼀个返回单个值的数学函数。SQL 中的聚合函数是：

AVG（）——返回平均值

COUNT（）——返回⾏数

MAX（）——返回最⼤值

MIN（）——返回最⼩值

ROUND（）——基于⼗进制规范，此函数对数字字段进⾏舍⼊

SUM（）——返回总和

18.主键是⽤⾃增还是 UUID?

最好是⽤⾃增主键，主要是以下两个原因：

1.如果表使⽤⾃增主键，那么每次插⼊新的记录，记录就会顺序添加到当前索引节点的后续位置，当⼀⻚写

满，就会⾃动开辟⼀个新的⻚。

2.如果使⽤⾮⾃增主键（如 uuid），由于每次插⼊主键的值近似于随机，因此每次新纪录都要被插到索引

⻚的随机某个位置，此时 MySQL 为了将新记录插到合适位置⽽移动数据，甚⾄⽬标⻚⾯可能已经被回写到

磁盘上⽽从缓存中清掉，此时⼜要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分⻚操作造成

索引碎⽚，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充⻚⾯。

不过，也不是所有的场景下都得使⽤⾃增主键，可能场景下，主键必须⾃⼰⽣成，不在乎那些性能的开

销。那也没有问题。

9798

char 和 varchar 类型声明⻓度表示⽤户想保存的最⼤字符数，其中 char(M)定义的列的⻓度为固定的，M 的

取值可以 0-255 之间，当保存 char 值时，在它们的右边填充空格以达到指定的⻓度。

当检索到 char 值时，尾部的空格被删除掉。在存储或检索过程中不进⾏⼤⼩写转换。char 存储定⻓数据很

⽅便，char 字段上的索引效率很⾼。

varchar(M)定义的列的⻓度是可变⻓度字符串，在 MySQL5.0 以上的版本中，varchar 的数据类型⻓度⽀持

到了 65535，因为起始位和结束位占去了 3 个字节，所以其整体最⼤⻓度为 65532 字节（

varchar 的最⼤有

效⻓度由最⼤⾏⼤⼩和使⽤的字符集确定）。

同样在 char 和 varchar 尾部加空格，检索时 char 类型后的被删掉，⽽ varchar 类型的保存。

最好是主键是⽆意义的⾃增 ID，然后另外创建⼀个业务主键 ID， 因为任何有业务含义的列都有改变的可能

性,主键⼀旦带上了业务含义，那么主键就有可能发⽣变更。主键⼀旦发⽣变更，该数据在磁盘上的存储位

置就会发⽣变更，有可能会引发⻚分裂，产⽣空间碎⽚。

还有就是，带有业务含义的主键，不⼀定是顺序⾃增的。那么就会导致数据的插⼊顺序，并不能保证后⾯

插⼊数据的主键⼀定⽐前⾯的数据⼤。如果出现了，后⾯插⼊数据的主键⽐前⾯的⼩，就有可能引发⻚分

裂，产⽣空间碎⽚。

货币字段⼀般都⽤ Decimal 类型， float 和 double 是以⼆进制存储的，数据⼤的时候，可能存在误差。

在经常需要搜索的列上，可以加快搜索的速度；

在作为主键的列上，强制该列的唯⼀性和组织表中数据的排列结构；

在经常⽤在连接的列上，这些列主要是⼀些外键，可以加快连接的速度；

在经常需要根据范围进⾏搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；

19.CHAR 和 VARCHAR 的区别？

20.主键为什么不推荐有业务含义?

21.货币字段⽤什么类型?

22.索引应该建在那些列上？在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利⽤索引的排序，加快排序查询时

间；

在经常使⽤在 WHERE ⼦句中的列上⾯创建索引，加快条件的判断速度。

23.什么是存储过程？有哪些优缺点？

存储过程就像我们编程语⾔中的函数⼀样，封装了我们的代码(PLSQL、T-SQL)

存储过程的优点

能够将代码封装起来

保存在数据库之中

让编程语⾔进⾏调⽤

存储过程是⼀个预编译的代码块，执⾏效率⽐较⾼

⼀个存储过程替代⼤量 T_SQL 语句 ，可以降低⽹络通信量，提⾼通信速率

存储过程的缺点：

每个数据库的存储过程语法⼏乎都不⼀样，⼗分难以维护（不通⽤）

业务逻辑放在数据库上，难以迭代

24.字段为什么要定义为 NOT NULL?

⼀般情况，都会设置⼀个默认值，不会出现字段⾥⾯有 null，⼜有空的情况。主要有以下⼏个原因：

索引性能不好，Mysql 难以优化引⽤可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多

的存储空间，还需要 mysql 内部进⾏特殊处理。可空列被索引后，每条记录都需要⼀个额外的字节，还能导

致 MYisam 中固定⼤⼩的索引变成可变⼤⼩的索引。

如果某列存在 null 的情况，可能导致 count() 等函数执⾏不对的情况。看⼀下 2 个图就明⽩了：

sql 语句写着也麻烦，既要判断是否为空，⼜要判断是否为 null 等。

25 索引的分类有哪些？

唯⼀索引：唯⼀索引不允许两⾏具有相同的索引值

99 主键索引：为表定义⼀个主键将⾃动创建主键索引，主键索引是唯⼀索引的特殊类型。主键索引要求主键

中的每个值是唯⼀的，并且不能为空

聚集索引(Clustered)：表中各⾏的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有⼀个

⾮聚集索引(Non-clustered)：⾮聚集索引指定表的逻辑顺序。数据存储在⼀个位置，索引存储在另⼀个位

置，索引中包含指向数据存储位置的指针。可以有多个，⼩于 249 个

26 时间字段⽤什么类型?

这个看具体情况和实际场景，timestamp ，datatime ，bigint 都⾏！把理由讲清楚就⾏！

timestamp，该类型是四个字节的整数，它能表示的时间范围为 1970-01-01 08:00:01 到 2038-01-19

11:14:07。2038 年以后的时间，是⽆法⽤ timestamp 类型存储的。

但是它有⼀个优势，timestamp 类型是带有时区信息的。⼀旦你系统中的时区发⽣改变，例如你修改了时

区，该字段的值会⾃动变更。这个特性⽤来做⼀些国际化⼤项⽬，跨时区的应⽤时，特别注意！

datetime，占⽤ 8 个字节，它存储的时间范围为 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显

然，存储时间范围更⼤。但是它坑的地⽅在于，它存储的是时间绝对值，不带有时区信息。如果你改变数

据库的时区，该项的值不会⾃⼰发⽣变更！

bigint，也是 8 个字节，⾃⼰维护⼀个时间戳，查询效率⾼，不过数据写⼊，显示都需要做转换。

27.什么是最左前缀原则？

最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续⼀列或⼏列，则此列就可以被⽤

到。如下：

1 select \* from user where name=xx and city=xx ; ／／可以命中索引

2 select \* from user where name=xx ; // 可以命中索引

3 select \* from user where city=xx ; // ⽆法命中索引

这⾥需要注意的是，查询的时候如果两个条件都⽤上了，但是顺序不同，如 city= xx and name ＝ xx，那

么现在的查询引擎会⾃动优化为匹配联合索引的顺序，这样是能够命中索引的。

100101

由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前

⾯。ORDER BY ⼦句也遵循此规则。

事务简单来说：⼀个 Session 中所进⾏所有的操作，要么同时成功，要么同时失败

ACID — 数据库事务正确执⾏的四个基本要素包含：

原⼦性（

Atomicity）、⼀致性（Consistency）、隔离性（

Isolation）、持久性（Durability）。

⼀个⽀持事务（

Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（

Transaction

processing）当中⽆法保证数据的正确性，交易过程极可能达不到交易。

举个例⼦:A 向 B 转账，转账这个流程中如果出现问题，事务可以让数据恢复成原来⼀样【

A 账户的钱没变，

B 账户的钱也没变】。

MySQL 服务器通过权限表来控制⽤户对数据库的访问，权限表存放在 mysql 数据库⾥，由

mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。下⾯分别

介绍⼀下这些表的结构和内容：

user 权限表：记录允许连接到服务器的⽤户帐号信息，⾥⾯的权限是全局级的。

db 权限表：记录各个帐号在各个数据库上的操作权限。

table_priv 权限表：记录数据表级的操作权限。

columns_priv 权限表：记录数据列级的操作权限。

host 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受 GRANT 和

REVOKE 语句的影响。

表记录太少

经常插⼊、删除、修改的表

38.什么是事务？

39.mysql 有关权限的表都有哪⼏个?

40.什么情况下应不建或少建索引?数据重复且分布平均的表字段，假如⼀个表有 10 万⾏记录，有⼀个字段 A 只有 T 和 F 两种值，且每个值的分

布概率⼤约为 50%，那么对这种表 A 字段建索引⼀般不会提⾼数据库的查询速度。

经常和主字段⼀块查询但主字段索引值⽐较多的表字段

41.数据表损坏的修复⽅式有哪些？

使⽤ myisamchk 来修复，具体步骤：

1.修复前将 mysql 服务停⽌。

2.打开命令⾏⽅式，然后进⼊到 mysql 的/bin ⽬录。

3.执⾏ myisamchk –recover 数据库所在路径/\*.MYI

使⽤ repair table 或者 OPTIMIZE table 命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE

TABLE table_name 优化表 REPAIR TABLE ⽤于修复被破坏的表。

OPTIMIZE TABLE ⽤于回收闲置的数据库空间，当表上的数据⾏被删除时，所占据的磁盘空间并没有⽴即

被回收，使⽤了 OPTIMIZE TABLE 命令后这些空间将被回收，并且对磁盘上的数据⾏进⾏重排（注意：是

磁盘上，⽽⾮数据库）

42.MySQL 数据库 cpu 飙升到 100%的话他怎么处理？

列出所有进程 show processlist 观察所有进程 多秒没有状态变化的(⼲掉)

查看慢查询，找出执⾏时间⻓的 sql；

explain 分析 sql 是否⾛索引，sql 优化；

检查其他⼦系统是否正常，是否缓存失效引起，需要查看 buffer 命中率；

43.维护数据库的完整性和⼀致性，你喜欢⽤触发器还是⾃写业务逻辑？为什么？

尽可能使⽤约束，如 check,主键，外键，⾮空字段等来约束，这样做效率最⾼，也最⽅便。其次是使⽤触

发器，这种⽅法可以保证，⽆论什么业务系统访问数据库都可以保证数据的完整新和⼀致性。

最后考虑的是⾃写业务逻辑，但这样做麻烦，编程复杂，效率低下。

10244.游标是什么？

是对查询出来的结果集作为⼀个单元来有效的处理。游标可以定在该单元中的特定⾏，从结果集的当前⾏

检索⼀⾏或多⾏。可以对结果集当前⾏做修改。⼀般不使⽤游标，但是需要逐条处理数据的时候，游标显

得⼗分重要。

45 数据库 NULL 是什么意思?

NULL(空)这个值是数据库世界⾥⼀个⾮常难缠的东⻄。

NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。假设您的 SQL Server 数据库⾥有

ANSI_NULLS，当然在默认情况下会有，对 NULL 这个值的任何⽐较都会⽣产⼀个 NULL 值。您不能把任何

值与⼀个 UNKNOWN 值进⾏⽐较，并在逻辑上希望获得⼀个答案。您必须使⽤ IS NULL 操作符。

46.关系型数据库和⾮关系型数据库区别？

关系型数据库的优点：

1、容易理解：⼆维表结构是⾮常贴近逻辑世界⼀个概念，关系模型相对⽹状、层次等其他模型来说更容易

理解；

2、使⽤⽅便：通⽤的 SQL 语⾔使得操作关系型数据库⾮常⽅便；

3、易于维护：丰富的完整性(实体完整性、参照完整性和⽤户定义的完整性)⼤⼤减低了数据冗余和数据不

⼀致的概率；

4、⽀持 SQL，可⽤于复杂的查询。

5.⽀持事务

关系型数据库的缺点：

1、为了维护⼀致性所付出的巨⼤代价就是其读写性能⽐较差；

2、固定的表结构；

3、不⽀持⾼并发读写需求；

1034、不⽀持海量数据的⾼效率读写

⾮关系型数据库优点：

1.⽆需经过 sql 层的解析，读写性能很⾼

2.基于键值对，数据没有耦合性，容易扩展

3.存储数据的格式：nosql 的存储格式是 key,value 形式

⾮关系型数据库缺点：

不提供 sql

47.查询语句的执⾏先后顺序？

查询中⽤到的关键词主要包含六个，并且他们的顺序依次为 select--from--where--group by--

having--order by

其中 select 和 from 是必须的，其他关键词是可选的，这六个关键词的执⾏顺序 与 sql 语句的书写顺序并不

是⼀样的，⽽是按照下⾯的顺序来执⾏

from:需要从哪个数据表检索数据

where:过滤表中数据的条件

group by:如何将上⾯过滤出的数据分组

having:对上⾯已经分组的数据进⾏过滤的条件

select:查看结果集中的哪个列，或列的计算结果

order by :按照什么样的顺序来查看返回的数据

48.什么情况下会造成死锁？

所谓死锁: 是指两个或两个以上的进程在执⾏过程中。因争夺资源⽽造成的⼀种互相等待的现象,若⽆外⼒

作⽤,它们都将⽆法推进下去。此时称系统处于死锁状态或系统产⽣了死锁,这些永远在互相等竺的进程称为

104 死锁进程。表级锁不会产⽣死锁.所以解决死锁主要还是针对于最常⽤的 InnoDB。

死锁的关键在于：两个(或以上)的 Session 加锁的顺序不⼀致。

那么对应的解决死锁问题的关键就是：让不同的 session 加锁有次序。

49 死锁如何解决？

查出的线程杀死 kill

1 SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;

设置锁的超时时间

Innodb ⾏锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。

⽣产环境不推荐使⽤过⼤的 innodb_lock_wait_timeout 参数值

该参数⽀持在会话级别修改，⽅便应⽤在会话级别单独设置某些特殊操作的⾏锁等待超时时间，如下：

1 set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb ⾏锁等待超时时

间，单位秒。

50.触发器的作⽤？

触发器是⼀中特殊的存储过程，主要是通过事件来触发⽽被执⾏的。它可以强化约束，来维护数据的完整

性和⼀致性，可以跟踪数据库内的操作从⽽不允许未经许可的更新和变化。可以联级运算。如，某表上的

触发器上包含对另⼀个表的数据操作，⽽该操作⼜会导致该表触发器被触发。

51 在数据库中查询语句速度很慢，如何优化？

1.建索引 ,2.减少表之间的关联 3.优化 sql，尽量让 sql 很快定位数据，不要让 sql 做全表查询，应该⾛索引,

把数据 量⼤的表排在前⾯ 4.简化查询字段，没⽤的字段不要，已经对返回结果的控制，尽量返回少量数据

5.尽量⽤ PreparedStatement 来查询，不要⽤ Statement

52 什么是 PL/SQL？

105106

PL/SQL 是⼀种程序语⾔，叫做过程化 SQL 语⾔（

Procedural Language/SQL）。PL/SQL 是 Oracle 数据

库对 SQL 语句的扩展。在普通 SQL 语句的使⽤上增加了编程语⾔的特点，所以 PL/SQL 把数据操作和查询

语句组织在 PL/SQL 代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。PL/SQL

只有 Oracle 数据库有。 MySQL ⽬前不⽀持 PL/SQL 的。

Update teacher set salary=salary+500

.tif

包括 40 岁和 50 岁

SQL 中的 drop、delete、truncate 都表示删除，但是三者有⼀些差别

delete 和 truncate 只删除表的数据不删除表的结构

速度,⼀般来说: drop> truncate >delete

delete 语句是 dml,这个操作会放到 rollback segement 中,事务提交之后才⽣效;

如果有相应的 trigger,执⾏的时候将被触发. truncate,drop 是 ddl, 操作⽴即⽣效,原数据不放到 rollback

segment 中,不能回滚. 操作不触发 trigger.

不再需要⼀张表的时候，⽤ drop

想删除部分数据⾏时候，⽤ delete，并且带上 where ⼦句

保留表⽽删除所有数据的时候⽤ truncate

53 使⽤ SQL 命令将教师表 teacher 中⼯资 salary 字段的值增加 500，应该使⽤的命令?

54.mdf、.ldf、.tif 、.ndf 哪个不是 sql 数据库⽂件的后缀？

55.SQL 语⾔中，条件“年龄 BETWEEN 40 AND 50”表示年龄在 40 ⾄ 50 之间更准确的描述是?

56.drop、delete 与 truncate 分别在什么场景之下使⽤？

57.MyISAM 索引与 InnoDB 索引的区别？InnoDB 索引是聚簇索引，MyISAM 索引是⾮聚簇索引。

InnoDB 的主键索引的叶⼦节点存储着⾏数据，因此主键索引⾮常⾼效。

MyISAM 索引的叶⼦节点存储的是⾏数据地址，需要再寻址⼀次才能得到数据。

InnoDB ⾮主键索引的叶⼦节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会⾮常⾼效

58.有哪⼏种类型的 SQL 命令？

SQL 命令分为以下类型：

DDL（数据定义语⾔） - ⽤于定义数据库的结构。

DCL（数据控制语⾔） - ⽤于为⽤户提供权限。

DML（数据操作语⾔） - ⽤于管理数据。

DQL（数据查询语⾔） - 所有命令都在 SQL 中，⽤于检索 DQL 中的数据。

TCL（事务控制语⾔） - ⽤于管理 DML 所做的更改。

107.NET/C#⾯试题汇总系列：数据库 SQL 查询（附

建表语句）

第 1 题

⽤⼀条 SQL 语句 查询出每⻔课都⼤于 80 分的学⽣姓名

建表语句：

1 create table tableA

2 (

3 name varchar(10),

4 kecheng varchar(10),

5 fenshu int(11)

6 )DEFAULT CHARSET = 'utf8';

插⼊数据

1 insert into tableA values ('张三','语⽂',81);

2 insert into tableA values ('张三','数学',75);

3 insert into tableA values ('李四','语⽂',76);

4 insert into tableA values ('李四','数学',90);

5 insert into tableA values ('王五','语⽂',81);

6 insert into tableA values ('王五','数学',100);

7 insert into tableA values ('王五','英语',90);

答案有 3 种：

1 答案 A：

2 select distinct name from tableA where name not in (select distinc

t name from tableA where fenshu<=80)

3

1084 答案 B：

5 select name from tableA group by name having min(fenshu)>80

6

7 答案 C：

8 select name from tableA group by name having count(kecheng)>=3 and

min(fenshu)>=80

第 2 题

⼀道 SQL 语句⾯试题，关于 group by 表内容：

2005-05-09 胜

2005-05-09 胜

2005-05-09 负

2005-05-09 负

2005-05-10 胜

2005-05-10 负

2005-05-10 负

如果要⽣成下列结果, 该如何写 sql 语句?

建表语句：

1 create table tableb (

2 rq varchar(10),

3 shengfu nchar(1)

4 )DEFAULT CHARSET = 'utf8';

109 插⼊数据：

1 insert into tableb values('2005-05-09','胜');

2 insert into tableb values('2005-05-09','胜');

3 insert into tableb values('2005-05-09','负');

4 insert into tableb values('2005-05-09','负');

5 insert into tableb values('2005-05-10','胜');

6 insert into tableb values('2005-05-10','负');

7 insert into tableb values('2005-05-10','负')

答案：

1 select rq, sum(case when shengfu='胜' then 1 else 0 end)'胜',sum(ca

se when shengfu='负' then 1 else 0 end)'负' from tableb group by rq

第 3 题

⼀个叫 team 的表，⾥⾯只有⼀个字段 name, ⼀共有 4 条纪录，分别是 a,b,c,d, 对应四个球对，现在四个

球对进⾏⽐赛，⽤⼀条 sql 语句显示所有可能的⽐赛组合

team 表建表语句:

1 CREATE TABLE team (

2 `name` varchar(20)

3 ) DEFAULT CHARSET=utf8;

插⼊数据：

1 INSERT INTO team VALUES ('a');

2 INSERT INTO team VALUES ('b');

3 INSERT INTO team VALUES ('c');

4 INSERT INTO team VALUES ('d')

答案：

1101 select a.name, b.name

2 from team a, team b

3 where a.name < b.name

结果如图所示：

第 4 题

怎么把这样⼀个表⼉

查成这样⼀个结果

建表语句：

1 CREATE TABLE table1 (

2 `year` int (11),

3 `month` int (11),

4 `amount` DECIMAL

5 ) DEFAULT CHARSET=utf8;

111 插⼊数据：

1 INSERT INTO table1 VALUES (1991,1,1.1);

2 INSERT INTO table1 VALUES (1991,2,1.2);

3 INSERT INTO table1 VALUES (1991,3,1.3);

4 INSERT INTO table1 VALUES (1991,4,1.4);

5 INSERT INTO table1 VALUES (1992,1,2.1);

6 INSERT INTO table1 VALUES (1992,2,2.2);

7 INSERT INTO table1 VALUES (1992,3,2.3);

8 INSERT INTO table1 VALUES (1992,4,2.4);

答案：

1 select year,

2 (select amount from aaa m where month=1 and m.year=aaa.year) a

s m1,

3 (select amount from aaa m where month=2 and m.year=aaa.year) a

s m2,

4 (select amount from aaa m where month=3 and m.year=aaa.year) a

s m3,

5 (select amount from aaa m where month=4 and m.year=aaa.year) a

s m4

6 from aaa group by year

第 5 题

⼀张部⻔表，⼀张员⼯表

部⻔表建表语句：

1 create table dpt

2 (

3 id int(11),

4 department varchar(12)

1125 )DEFAULT CHARSET=utf8;

插⼊数据：

1 insert into dpt values(1,'设计');

2 insert into dpt values(2,'市场');

3 insert into dpt values(3,'售后')

员⼯表建表语句：

1 create table emy

2 (

3 id int(11),

4 dptID int(11),

5 `name` varchar(12)

6 )DEFAULT CHARSET=utf8;

插⼊数据

1 insert into emy values(1,1,'张三');

2 insert into emy values(2,1,'李四');

3 insert into emy values(3,2,'王五');

4 insert into emy values(4,3,'彭六');

5 insert into emy values(5,4,'陈七')

第 6 题

删除除了⾃动编号不同, 其他都相同的学⽣冗余信息

学⽣表建表语句：

1 create table tablestudent

2 (

1133 id int(11),

4 studentno varchar(10),

5 studentname varchar(10),

6 classno varchar(10),

7 classname varchar (11),

8 score int (11)

9 )DEFAULT CHARSET = 'utf8';

插⼊数据:

1 insert into tablestudent values (1,'2005001','张三','0001','数学',6

9);

2 insert into tablestudent values (2,'2005002','李四','0001','数学',6

9);

3 insert into tablestudent values (3,'2005001','张三','0001','数学',6

9.

如图所示：

答案：

在 mysql 中，不能通过嵌套⼦查询来直接删除或者修改记录，需要通过别名来指定嵌套⼦查询作为⼀个临时

表。

给嵌套⼦查询的结果取⼀个别名，然后从这个表中再次查询出记录,然后再做删除或者修改操作。

1 delete from tablestudent

2 where id not in

3 (select a.id from

4 (select id from tablestudent

5 group by studentno, studentname, classno,classname, score)

6 a)

114 第 7 题

关于年度、季度 SQL 统计查询的⾯试题

A 表 - 销售数据表，其中 adddate 是销售时间，company 是客户公司，money 是销售⾦额，sales 是销售

员

B 表 - 产品销售表，aid 对应 A 表中的 id，pid 对应是 C 表中产品表。

C 表 - 产品类型表

1. 销售数据表建表语句：

1 CREATE TABLE `a` (

2 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,

3 `adddate` datetime NOT NULL,

4 `company` varchar(10) DEFAULT NULL,

5 `money` decimal(7,2) DEFAULT NULL,

6 `sales` varchar(20) DEFAULT NULL,

7 PRIMARY KEY (`id`)

8 ) AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

插⼊数据：

1 insert into `a`(`id`,`adddate`,`company`,`money`,`sales`)

2 values

3 (1,'2011-01-02 00:00:00','A','10000.00','张三'),

4 (2,'2011-07-03 00:00:00','B','50000.00','王五'),

5 (3,'2011-09-03 00:00:00','A','20000.00','赵六'),

6 (4,'2012-07-03 00:00:00','A','10000.00','李四'),

7 (5,'2013-10-03 00:00:00','B','5000.00','麻⼦'),

8 (6,'2013-07-04 00:00:00','B','6000.00','⼩柒');

1152.产品销售表建表语句:

1 DROP TABLE IF EXISTS `b`;

2 CREATE TABLE `b` (

3 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,

4 `product` varchar(20) DEFAULT NULL,

5 `pid` int(11) DEFAULT NULL,

6 `price` decimal(7,2) DEFAULT NULL,

7 `number` int(11) DEFAULT NULL,

8 PRIMARY KEY (`id`)

9 ) AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

插⼊数据：

1 insert into `b`(`id`,`product`,`pid`,`price`,`number`)

2 values

3 (1,'AC1100',1,'10000.00',2),

4 (2,'AC1200',1,'20000.00',3),

5 (3,'SSL1100',2,'10000.00',1),

6 (4,'WOC1100',3,'10000.00',1);

3.产品类型表建表语句:

1161 CREATE TABLE `c` (

2 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,

3 `type` varchar(20) DEFAULT NULL,

4 PRIMARY KEY (`id`)

5 ) AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

插⼊数据：

1 insert into `c`(`id`,`type`)

2 values (1,'AC'),

3 (2,'SSL'),

4 (3,'WOC');

问题 1：

请使⽤ SQL 语句统计 2011 年⾄ 2013 年三年中每个季度的销售⾦额?

另外在 MySQL 中有个特殊的规定，即不允许使⽤列别名作为查询条件,实在要执⾏，只好把新字段的组成在

条件⾥再实现⼀遍

据说是因为 MySql 中列的别名本来是返回结果的时候才显示的.这个还没有得到证实，纯属猜测！

1 SELECT

2 YEAR(`adddate`) AS yer,

3 QUARTER(`adddate`) AS jd,

4 SUM(money)

5 FROM a

6 WHERE YEAR(`adddate`) IN ('2011','2012','2013')

7 GROUP BY QUARTER(`adddate`),YEAR(`adddate`)

117 问题 2：

请使⽤ SQL 语句按如下格式统计 2013 年销售⾦额前 5 位的销售员

不知道是不是考察：order by 和 group by 共⽤的问题。order by 必须放在 group by 后⾯

1 SELECT id AS `no`,sales,SUM(`money`) AS money FROM a WHERE YEAR(`a

dddate`) = '2013' GROUP BY sales ORDER BY money DESC LIMIT 5

问题 3：

请⽤ SQL 语句统计出哪个产品线的销售⾦额最多?

1 SELECT c.`type`,MAX(tab.tt) FROM (SELECT pid,SUM(price\*number) AS

tt FROM b GROUP BY pid) AS tab LEFT JOIN c ON tab.pid = c.`id`

第 8 题

数据库的表设计如下：

部⻔表：部⻔编号，部⻔名称，地址；

员⼯表：员⼯编号，员⼯名字，职务，管理编号，⼊职⽇期，薪资，奖⾦，部⻔编号；

部⻔表建表语句：

1 CREATE TABLE emp(

2 empno INT PRIMARY KEY,

3 ename VARCHAR(20) NOT NULL,

4 job VARCHAR(20) CHECK (job IN('CLERK','SALESMAN','MANAGER','ANALY

ST')),mgp INT,

5 hiredate DATE ,

6 sal DECIMAL(10,2),

7 comm DECIMAL(10,2),

1188 deptno INT,

9 CONSTRAINT pk_we FOREIGN KEY (deptno) REFERENCES dept (deptno)

10 )DEFAULT CHARSET=utf8;

插⼊数据：

1 INSERT INTO dept VALUES (10,'ACCOUNTING','NEWTORK');

2 INSERT INTO dept VALUES (20,'RESEARCH','DALLAS');

3 INSERT INTO dept VALUES (30,'SALES','CHICAGO');

4 INSERT INTO dept VALUES (40,'OPERATIONS','BOSTON');

如图所示：

员⼯表建表语句：

1 CREATE TABLE emp(

2 empno INT PRIMARY KEY,

3 ename VARCHAR(20) NOT NULL,

4 job VARCHAR(20) CHECK (job IN('CLERK','SALESMAN','MANAGER','ANALY

ST')),mgp INT,

5 hiredate DATE ,

6 sal DECIMAL(10,2),

7 comm DECIMAL(10,2),

8 deptno INT,

9 CONSTRAINT pk_we FOREIGN KEY (deptno) REFERENCES dept (deptno)

10 )DEFAULT CHARSET=utf8;

插⼊数据：

1191 INSERT INTO dept VALUES (10,'ACCOUNTING','NEWTORK');

2 INSERT INTO dept VALUES (20,'RESEARCH','DALLAS');

3 INSERT INTO dept VALUES (30,'SALES','CHICAGO');

4 INSERT INTO dept VALUES (40,'OPERATIONS','BOSTON');

如图所示：

问题如下：

1、列出⾄少有⼀个雇员的所有部⻔

1 select dname,count(empno) as 部⻔⼈数 from dept,emp where dept.dept

no=emp.deptno

2 group by dname

3 having count(empno)>=1;

2、列出薪⾦⽐"SMITH"多的所有雇员

1 select \* from emp where sal>(select sal from emp where ename='SMIT

H');

3. 列出⼊职⽇期早于其直接上级的所有雇员

1 select \* from emp e1 where hiredate <(select hiredate from emp e2

where e2.empno=e1.mgp);

4. 找员⼯姓名和直接上级的名字

1201 select e1.ename 员⼯姓名,e2.ename 直接上级 from emp e1,emp e2 where e

1.mgp=e2.empno;

5. 显示部⻔名称和⼈数

1 select dname,count(empno) as 部⻔⼈数 from dept,emp where dept.dept

no=emp.deptno

2 group by dname;

6. 显示每个部⻔的最⾼⼯资的员⼯

1 SELECT ename,sal,e1.deptno FROM emp e1

2 WHERE sal =

3 (SELECT MAX(sal) FROM emp e2 WHERE e2.`deptno`=e1.`deptno`

4 GROUP BY e2.`deptno`);

7. 显示每个部⻔的⼯资前 2 名的员⼯

1 select deptno, ename, sal

2 from emp e1

3 where

4 (

5 select count(1)

6 from emp e2

7 where e2.deptno=e1.deptno and e2.sal>=e1.sal

8 ) <=2

9 order by deptno, sal desc;

121
